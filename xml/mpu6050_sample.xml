<?xml version="1.0" encoding="UTF-8"?>
<Device statusCode="0" statusMessage="OK, device located successfully" xmlns="http://www.i2cdevlib.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.i2cdevlib.com i2cdevlib.xsd">
  <DeviceId>1</DeviceId>
  <ShortName><![CDATA[MPU6050]]></ShortName>
  <Name><![CDATA[MPU-6050 6-axis accelerometer/gyroscope]]></Name>
  <Description><![CDATA[&lt;blockquote&gt;The MPU-6000&amp;trade; family provides the world&#039;s first integrated 6-axis MotionProcessing&amp;trade; solution that eliminates the package-level gyro/accel cross-axis misalignment associated with discrete solutions. The devices combine a 3-axis gyroscope and a 3-axis accelerometer on the same silicon die together with an onboard Digital Motion Processor&amp;trade; (DMP&amp;trade;) capable of processing complex 9-axis MotionFusion algorithms. The parts&#039; integrated 9-axis MotionFusion algorithms access external magnetometers or other sensors through an auxiliary master I2C bus, allowing the devices to gather a full set of sensor data without intervention from the system processor. The devices are offered in the same 4x4x0.9 mm QFN footprint and pinout as the current MPU-3000&amp;trade; family of integrated 3-axis gyroscopes, providing a simple upgrade path and making it easy to fit on space constrained boards.&lt;br /&gt;&lt;br /&gt;&lt;i&gt;(Source: &lt;a href=&quot;http://invensense.com/mems/gyro/mpu6000.html&quot;&gt;InvenSense product description&lt;/a&gt;, 9/28/2011)&lt;/i&gt;&lt;/blockquote&gt;

&lt;p&gt;Due to the lack of good publicly available documentation about the inner workings of this device, all DMP-related information has been reverse-engineered from I2C signal analysis correlated against the company-provided Embedded MotionApps software (available on the InvenSense &lt;a href=&quot;http://www.invensense.com/developers/&quot;&gt;Developers Corner&lt;/a&gt; site). This backwards discovery effort is incomplete and ongoing, and will hopefully end up in a feature-complete device library that supports full DMP configuration. Currently, the source code available will only provide basic device configuration and raw accel/gryo readings (which is certainly useful, but missing the main selling point of the MPU-6000 series, which is the device-powered motion processing ability).&lt;/p&gt;]]></Description>
  <ImageURL>http://www.i2cdevlib.com/assets/images/devices/mpu6050-th.jpg</ImageURL>
  <ManufacturerId>1</ManufacturerId>
  <RegisterSize>8</RegisterSize>
  <RegisterEndian>1</RegisterEndian>
  <CodeStatus>16</CodeStatus>
  <DocumentationStatus>16</DocumentationStatus>
  <RegisterMapStatus>16</RegisterMapStatus>
  <Registers>
    <Register>
      <Address>0</Address>
      <ShortName><![CDATA[AUX_VDDIO]]></ShortName>
      <Name><![CDATA[Auxiliary I2C Supply Selection]]></Name>
      <Description><![CDATA[This register specifies the auxiliary I2C supply voltage level. Bits 6 through 0 are reserved.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[AUX_VDDIO]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[AUX_VDDIO configures the high logic level of the auxiliary I2C bus to be either VLOGIC or VDD. When set to 1, the auxiliary I2C bus high logic level is VDD. When cleared to 0, the auxiliary I2C bus high logic level is VLOGIC.]]></Description>
          <RW>0</RW>
          <DataType>set</DataType>
          <Options>
            <Option>
              <Value>0</Value>
              <Format>1</Format>
              <Name><![CDATA[VLOGIC]]></Name>
              <Description><![CDATA[AUX_VDDIO configures the high logic level of the auxiliary I2C bus to be either VLOGIC or VDD. When set to 1, the auxiliary I2C bus high logic level is VDD. When cleared to 0, the auxiliary I2C bus high logic level is VLOGIC.]]></Description>
            </Option>
            <Option>
              <Value>1</Value>
              <Format>1</Format>
              <Name><![CDATA[VDD]]></Name>
              <Description><![CDATA[AUX_VDDIO configures the high logic level of the auxiliary I2C bus to be either VLOGIC or VDD. When set to 1, the auxiliary I2C bus high logic level is VDD. When cleared to 0, the auxiliary I2C bus high logic level is VLOGIC.]]></Description>
            </Option>
          </Options>
        </Field>
        <Field>
          <StartBit>6</StartBit>
          <BitLength>6</BitLength>
          <ShortName><![CDATA[XG_OFFS_TC]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>0</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>0</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[OTP_BNK_VLD]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>0</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>1</Address>
      <ShortName><![CDATA[YG_OFFS_TC]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>6</StartBit>
          <BitLength>6</BitLength>
          <ShortName><![CDATA[YG_OFFS_TC]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>0</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>2</Address>
      <ShortName><![CDATA[ZG_OFFS_TC]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>6</StartBit>
          <BitLength>6</BitLength>
          <ShortName><![CDATA[ZG_OFFS_TC]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>0</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>3</Address>
      <ShortName><![CDATA[X_FINE_GAIN]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[X_FINE_GAIN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>0</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>4</Address>
      <ShortName><![CDATA[Y_FINE_GAIN]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[Y_FINE_GAIN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>0</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>5</Address>
      <ShortName><![CDATA[Z_FINE_GAIN]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[Z_FINE_GAIN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>0</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>6</Address>
      <ShortName><![CDATA[XA_OFFS_H]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>15</StartBit>
          <BitLength>16</BitLength>
          <ShortName><![CDATA[XA_OFFS]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>0</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>7</Address>
      <ShortName><![CDATA[XA_OFFS_L_TC]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
      </Fields>
    </Register>
    <Register>
      <Address>8</Address>
      <ShortName><![CDATA[YA_OFFS_H]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>15</StartBit>
          <BitLength>16</BitLength>
          <ShortName><![CDATA[YA_OFFS]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>0</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>9</Address>
      <ShortName><![CDATA[YA_OFFS_L_TC]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
      </Fields>
    </Register>
    <Register>
      <Address>10</Address>
      <ShortName><![CDATA[ZA_OFFS_H]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>15</StartBit>
          <BitLength>16</BitLength>
          <ShortName><![CDATA[ZA_OFFS]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>0</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>11</Address>
      <ShortName><![CDATA[ZA_OFFS_L_TC]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
      </Fields>
    </Register>
    <Register>
      <Address>19</Address>
      <ShortName><![CDATA[XG_OFFS_USRH]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>15</StartBit>
          <BitLength>16</BitLength>
          <ShortName><![CDATA[XG_OFFS_USR]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>0</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>20</Address>
      <ShortName><![CDATA[XG_OFFS_USRL]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
      </Fields>
    </Register>
    <Register>
      <Address>21</Address>
      <ShortName><![CDATA[YG_OFFS_USRH]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>15</StartBit>
          <BitLength>16</BitLength>
          <ShortName><![CDATA[YG_OFFS_USR]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>0</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>22</Address>
      <ShortName><![CDATA[YG_OFFS_USRL]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
      </Fields>
    </Register>
    <Register>
      <Address>23</Address>
      <ShortName><![CDATA[ZG_OFFS_USRH]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>15</StartBit>
          <BitLength>16</BitLength>
          <ShortName><![CDATA[ZG_OFFS_USR]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>0</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>24</Address>
      <ShortName><![CDATA[ZG_OFFS_USRL]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
      </Fields>
    </Register>
    <Register>
      <Address>25</Address>
      <ShortName><![CDATA[SMPLRT_DIV]]></ShortName>
      <Name><![CDATA[Sample Rate Divider]]></Name>
      <Description><![CDATA[This register specifies the divider from the gyroscope output rate used to generate the Sample Rate for the MPU-60X0.

The sensor register output, FIFO output, DMP sampling, Motion detection, Zero Motion detection, 
and Free Fall detection are all based on the Sample Rate.

The Sample Rate is generated by dividing the gyroscope output rate by SMPLRT_DIV:

Sample Rate = Gyroscope Output Rate / (1 + SMPLRT_DIV)

where Gyroscope Output Rate = 8kHz when the DLPF is disabled (DLPF_CFG = 0 or 7), and 1kHz when the DLPF is enabled (see Register 26).

Note: The accelerometer output rate is 1kHz. This means that for a Sample Rate greater than 1kHz, the same accelerometer sample may be output to the FIFO, DMP, and sensor registers more than once.

For a diagram of the gyroscope and accelerometer  signal paths, see Section 8 of the MPU-
6000/MPU-6050 Product Specification document. ]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[SMPLRT_DIV]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[8-bit unsigned value. The Sample Rate is determined by dividing the gyroscope output rate by this value.]]></Description>
          <RW>0</RW>
          <DataType>uns</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>26</Address>
      <ShortName><![CDATA[CONFIG]]></ShortName>
      <Name><![CDATA[Configuration]]></Name>
      <Description><![CDATA[This register configures the external Frame Synchronization (FSYNC) pin sampling and the Digital Low Pass Filter (DLPF) setting for both the gyroscopes and accelerometers.

An external signal connected to the FSYNC pin can be sampled by configuring EXT_SYNC_SET.

Signal changes to the FSYNC pin are latched so that short strobes may be captured. The latched FSYNC signal will be sampled at the Sampling Rate, as defined in register 25. After sampling, the latch will reset to the current FSYNC signal state.

The sampled value will be reported in place of the least significant bit  in a sensor  data register determined by the value of EXT_SYNC_SET according to the following table.

EXT_SYNC_SET FSYNC Bit Location
0 Input disabled
1 TEMP_OUT_L[0]
2 GYRO_XOUT_L[0]
3 GYRO_YOUT_L[0]
4 GYRO_ZOUT_L[0]
5 ACCEL_XOUT_L[0]
6 ACCEL_YOUT_L[0]
7 ACCEL_ZOUT_L[0]

The DLPF is configured by DLPF_CFG. The accelerometer and gyroscope are filtered according to the value of DLPF_CFG as shown in the table below.

DLPF_CFG Accelerometer (Fs = 1kHz) Gyroscope
Bandwidth (Hz) Delay (ms) Bandwidth (Hz) Delay (ms) Fs (kHz)
0 260 0 256 0.98 8
1 184 2.0 188 1.9 1
2 94 3.0 98 2.8 1
3 44 4.9 42 4.8 1
4 21 8.5 20 8.3 1
5 10 13.8 10 13.4 1
6 5 19.0 5 18.6 1
7 RESERVED RESERVED 8

Bit 7 and bit 6 are reserved.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>5</StartBit>
          <BitLength>3</BitLength>
          <ShortName><![CDATA[EXT_SYNC_SET]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[3-bit unsigned value. Configures the FSYNC pin sampling.]]></Description>
          <RW>0</RW>
          <DataType>set</DataType>
          <Options>
            <Option>
              <Value>0</Value>
              <Format>3</Format>
              <Name><![CDATA[Input disabled]]></Name>
              <Description><![CDATA[3-bit unsigned value. Configures the FSYNC pin sampling.]]></Description>
            </Option>
            <Option>
              <Value>1</Value>
              <Format>3</Format>
              <Name><![CDATA[TEMP_OUT_L[0]]]></Name>
              <Description><![CDATA[3-bit unsigned value. Configures the FSYNC pin sampling.]]></Description>
            </Option>
            <Option>
              <Value>2</Value>
              <Format>3</Format>
              <Name><![CDATA[GYRO_XOUT_L[0]]]></Name>
              <Description><![CDATA[3-bit unsigned value. Configures the FSYNC pin sampling.]]></Description>
            </Option>
            <Option>
              <Value>3</Value>
              <Format>3</Format>
              <Name><![CDATA[GYRO_YOUT_L[0]]]></Name>
              <Description><![CDATA[3-bit unsigned value. Configures the FSYNC pin sampling.]]></Description>
            </Option>
            <Option>
              <Value>4</Value>
              <Format>3</Format>
              <Name><![CDATA[GYRO_ZOUT_L[0]]]></Name>
              <Description><![CDATA[3-bit unsigned value. Configures the FSYNC pin sampling.]]></Description>
            </Option>
            <Option>
              <Value>5</Value>
              <Format>3</Format>
              <Name><![CDATA[ACCEL_XOUT_L[0]]]></Name>
              <Description><![CDATA[3-bit unsigned value. Configures the FSYNC pin sampling.]]></Description>
            </Option>
            <Option>
              <Value>6</Value>
              <Format>3</Format>
              <Name><![CDATA[ACCEL_YOUT_L[0]]]></Name>
              <Description><![CDATA[3-bit unsigned value. Configures the FSYNC pin sampling.]]></Description>
            </Option>
            <Option>
              <Value>7</Value>
              <Format>3</Format>
              <Name><![CDATA[ACCEL_ZOUT_L[0]]]></Name>
              <Description><![CDATA[3-bit unsigned value. Configures the FSYNC pin sampling.]]></Description>
            </Option>
          </Options>
        </Field>
        <Field>
          <StartBit>2</StartBit>
          <BitLength>3</BitLength>
          <ShortName><![CDATA[DLPF_CFG]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[3-bit unsigned value. Configures the DLPF setting]]></Description>
          <RW>0</RW>
          <DataType>set</DataType>
          <Options>
            <Option>
              <Value>0</Value>
              <Format>3</Format>
              <Name><![CDATA[260 Hz, 0 ms / 256 Hz, 0.98 ms, 8 kHz]]></Name>
              <Description><![CDATA[3-bit unsigned value. Configures the DLPF setting]]></Description>
            </Option>
            <Option>
              <Value>1</Value>
              <Format>3</Format>
              <Name><![CDATA[184 Hz, 2.0 ms / 188 Hz, 1.9 ms, 1 kHz]]></Name>
              <Description><![CDATA[3-bit unsigned value. Configures the DLPF setting]]></Description>
            </Option>
            <Option>
              <Value>2</Value>
              <Format>3</Format>
              <Name><![CDATA[94 Hz, 3.0 ms / 98 Hz, 2.8 1 ms, kHz]]></Name>
              <Description><![CDATA[3-bit unsigned value. Configures the DLPF setting]]></Description>
            </Option>
            <Option>
              <Value>3</Value>
              <Format>3</Format>
              <Name><![CDATA[44 Hz, 4.9 ms / 42 Hz, 4.8 1 ms, kHz]]></Name>
              <Description><![CDATA[3-bit unsigned value. Configures the DLPF setting]]></Description>
            </Option>
            <Option>
              <Value>4</Value>
              <Format>3</Format>
              <Name><![CDATA[21 Hz, 8.5 ms / 20 Hz, 8.3 1 ms, kHz]]></Name>
              <Description><![CDATA[3-bit unsigned value. Configures the DLPF setting]]></Description>
            </Option>
            <Option>
              <Value>5</Value>
              <Format>3</Format>
              <Name><![CDATA[10 Hz, 13.8 ms / 10 Hz, 13.4 ms, 1 kHz]]></Name>
              <Description><![CDATA[3-bit unsigned value. Configures the DLPF setting]]></Description>
            </Option>
            <Option>
              <Value>6</Value>
              <Format>3</Format>
              <Name><![CDATA[5 Hz, 19.0 ms / 5 Hz, 18.6 1 ms, kHz]]></Name>
              <Description><![CDATA[3-bit unsigned value. Configures the DLPF setting]]></Description>
            </Option>
            <Option>
              <Value>7</Value>
              <Format>3</Format>
              <Name><![CDATA[RESERVED / RESERVED, 8 kHz]]></Name>
              <Description><![CDATA[3-bit unsigned value. Configures the DLPF setting]]></Description>
            </Option>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>27</Address>
      <ShortName><![CDATA[GYRO_CONFIG]]></ShortName>
      <Name><![CDATA[Gyroscope Configuration]]></Name>
      <Description><![CDATA[This register is used to trigger gyroscope self-test and configure the gyroscopes’ full scale range.

Gyroscope self-test permits users to test the mechanical and electrical portions of the gyroscope. The self-test for each gyroscope axis can be activated by controlling the  XG_ST, YG_ST, and ZG_ST bits of this register. Self-test for each axis may be performed independently or all at the same time.

When self-test is activated, the on-board electronics will actuate the appropriate sensor. This actuation will move the sensor’s proof masses over a distance equivalent to a pre-defined Coriolis force. This proof mass displacement results in a change in the sensor output, which is reflected in the output signal. The output signal is used to observe the self-test response.

The self-test response is defined as follows:

Self-test response = Sensor output with self-test enabled – Sensor output without selftest enabled

The self-test limits for each gyroscope axis is provided in the electrical characteristics tables of  the MPU-6000/MPU-6050 Product Specification document. When the value of the self-test response is within the min/max limits of the product specification, the part has passed self test. When the self-test response exceeds the min/max values specified in the document, the part is deemed to have failed self-test. 

FS_SEL selects the full scale range of the gyroscope outputs according to the following table.

FS_SEL Full Scale Range
0 ± 250 °/s
1 ± 500 °/s
2 ± 1000 °/s
3 ± 2000 °/s

Bits 2 through 0 are reserved.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[XG_ST]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Setting this bit causes the X axis gyroscope to perform self test.]]></Description>
          <RW>2</RW>
          <DataType>trig</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>6</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[YG_ST]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Setting this bit causes the Y axis gyroscope to perform self test.]]></Description>
          <RW>2</RW>
          <DataType>trig</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>5</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[ZG_ST]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Setting this bit causes the Z axis gyroscope to perform self test.]]></Description>
          <RW>2</RW>
          <DataType>trig</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>4</StartBit>
          <BitLength>2</BitLength>
          <ShortName><![CDATA[FS_SEL]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[2-bit unsigned value.  Selects the full scale range of gyroscopes.]]></Description>
          <RW>0</RW>
          <DataType>set</DataType>
          <Options>
            <Option>
              <Value>0</Value>
              <Format>2</Format>
              <Name><![CDATA[± 250 °/s, 131 LSB/°/s]]></Name>
              <Description><![CDATA[2-bit unsigned value.  Selects the full scale range of gyroscopes.]]></Description>
            </Option>
            <Option>
              <Value>1</Value>
              <Format>2</Format>
              <Name><![CDATA[± 500 °/s, 65.5 LSB/°/s]]></Name>
              <Description><![CDATA[2-bit unsigned value.  Selects the full scale range of gyroscopes.]]></Description>
            </Option>
            <Option>
              <Value>2</Value>
              <Format>2</Format>
              <Name><![CDATA[± 1000 °/s, 32.8 LSB/°/s]]></Name>
              <Description><![CDATA[2-bit unsigned value.  Selects the full scale range of gyroscopes.]]></Description>
            </Option>
            <Option>
              <Value>3</Value>
              <Format>2</Format>
              <Name><![CDATA[± 2000 °/s, 16.4 LSB/°/s]]></Name>
              <Description><![CDATA[2-bit unsigned value.  Selects the full scale range of gyroscopes.]]></Description>
            </Option>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>28</Address>
      <ShortName><![CDATA[ACCEL_CONFIG]]></ShortName>
      <Name><![CDATA[Accelerometer Configuration]]></Name>
      <Description><![CDATA[This register is used to trigger accelerometer self test and configure the accelerometer full scale range. This register also configures the Digital High Pass Filter (DHPF).

Accelerometer self-test permits users  to test the mechanical and electrical portions of the accelerometer. The self-test for each accelerometer axis can be activated by controlling the XA_ST, YA_ST, and ZA_ST bits of this register. Self-test for each axis may be performed independently or all at the same time.

When self-test is activated, the on-board electronics will  actuate the appropriate sensor. This actuation simulates an external force. The  actuated  sensor, in turn, will produce a corresponding output signal. The output signal is used to observe the self-test response. 

The self-test response is defined as follows:

Self-test response = Sensor output with self-test enabled – Sensor output without self-test enabled

The self-test limits for each accelerometer axis is provided in the electrical characteristics tables of the MPU-6000/MPU-6050 Product Specification document. When the value of the self-test response is within the min/max limits of the product specification, the part has passed self test. When the selftest response exceeds the min/max values specified in the document, the part is deemed to have 
failed self-test.

AFS_SEL selects the full scale range of the accelerometer outputs according to the following table.

AFS_SEL Full Scale Range
0 ± 2g
1 ± 4g
2 ± 8g
3 ± 16g]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[XA_ST]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, the X-Axis accelerometer performs self test.]]></Description>
          <RW>2</RW>
          <DataType>trig</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>6</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[YA_ST]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, the Y-Axis accelerometer performs self test.]]></Description>
          <RW>2</RW>
          <DataType>trig</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>5</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[ZA_ST]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, the Z-Axis accelerometer performs self test.]]></Description>
          <RW>2</RW>
          <DataType>trig</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>4</StartBit>
          <BitLength>2</BitLength>
          <ShortName><![CDATA[AFS_SEL]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[2-bit unsigned value. Selects the full scale range of accelerometers.]]></Description>
          <RW>0</RW>
          <DataType>set</DataType>
          <Options>
            <Option>
              <Value>0</Value>
              <Format>2</Format>
              <Name><![CDATA[± 2g, 16384 LSB/mg]]></Name>
              <Description><![CDATA[2-bit unsigned value. Selects the full scale range of accelerometers.]]></Description>
            </Option>
            <Option>
              <Value>1</Value>
              <Format>2</Format>
              <Name><![CDATA[± 4g, 8192 LSB/mg]]></Name>
              <Description><![CDATA[2-bit unsigned value. Selects the full scale range of accelerometers.]]></Description>
            </Option>
            <Option>
              <Value>2</Value>
              <Format>2</Format>
              <Name><![CDATA[± 8g, 4096 LSB/mg]]></Name>
              <Description><![CDATA[2-bit unsigned value. Selects the full scale range of accelerometers.]]></Description>
            </Option>
            <Option>
              <Value>3</Value>
              <Format>2</Format>
              <Name><![CDATA[± 16g, 2048 LSB/mg]]></Name>
              <Description><![CDATA[2-bit unsigned value. Selects the full scale range of accelerometers.]]></Description>
            </Option>
          </Options>
        </Field>
        <Field>
          <StartBit>2</StartBit>
          <BitLength>3</BitLength>
          <ShortName><![CDATA[ACCEL_HPF]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[3-bit unsigned value. Selects the Digital High Pass Filter configuration.

ACCEL_HPF configures the DHPF available in the path leading to motion detectors (Free Fall, Motion threshold, and Zero Motion). The high pass filter output is not available to the data registers (see Figure in Section 8 of the MPU-6000/MPU-6050 Product Specification document).

The high pass filter has three modes: 

- Reset:  The filter output settles to zero within one sample. This effectively disables the high pass filter. This mode may be toggled to quickly settle the filter.
- On:  The high pass filter will pass signals above the cut off frequency.
- Hold:  When triggered, the filter holds the present sample. The filter output will be the difference between the input sample and the held sample.

ACCEL_HPF Filter Mode Cut-off Frequency
0 Reset None
1 On 5Hz
2 On 2.5Hz
3 On 1.25Hz
4 On 0.63Hz
7 Hold None]]></Description>
          <RW>0</RW>
          <DataType>set</DataType>
          <Options>
            <Option>
              <Value>0</Value>
              <Format>3</Format>
              <Name><![CDATA[Reset]]></Name>
              <Description><![CDATA[3-bit unsigned value. Selects the Digital High Pass Filter configuration.

ACCEL_HPF configures the DHPF available in the path leading to motion detectors (Free Fall, Motion threshold, and Zero Motion). The high pass filter output is not available to the data registers (see Figure in Section 8 of the MPU-6000/MPU-6050 Product Specification document).

The high pass filter has three modes: 

- Reset:  The filter output settles to zero within one sample. This effectively disables the high pass filter. This mode may be toggled to quickly settle the filter.
- On:  The high pass filter will pass signals above the cut off frequency.
- Hold:  When triggered, the filter holds the present sample. The filter output will be the difference between the input sample and the held sample.

ACCEL_HPF Filter Mode Cut-off Frequency
0 Reset None
1 On 5Hz
2 On 2.5Hz
3 On 1.25Hz
4 On 0.63Hz
7 Hold None]]></Description>
            </Option>
            <Option>
              <Value>1</Value>
              <Format>3</Format>
              <Name><![CDATA[On @ 5 Hz]]></Name>
              <Description><![CDATA[3-bit unsigned value. Selects the Digital High Pass Filter configuration.

ACCEL_HPF configures the DHPF available in the path leading to motion detectors (Free Fall, Motion threshold, and Zero Motion). The high pass filter output is not available to the data registers (see Figure in Section 8 of the MPU-6000/MPU-6050 Product Specification document).

The high pass filter has three modes: 

- Reset:  The filter output settles to zero within one sample. This effectively disables the high pass filter. This mode may be toggled to quickly settle the filter.
- On:  The high pass filter will pass signals above the cut off frequency.
- Hold:  When triggered, the filter holds the present sample. The filter output will be the difference between the input sample and the held sample.

ACCEL_HPF Filter Mode Cut-off Frequency
0 Reset None
1 On 5Hz
2 On 2.5Hz
3 On 1.25Hz
4 On 0.63Hz
7 Hold None]]></Description>
            </Option>
            <Option>
              <Value>2</Value>
              <Format>3</Format>
              <Name><![CDATA[On @ 2.5 Hz]]></Name>
              <Description><![CDATA[3-bit unsigned value. Selects the Digital High Pass Filter configuration.

ACCEL_HPF configures the DHPF available in the path leading to motion detectors (Free Fall, Motion threshold, and Zero Motion). The high pass filter output is not available to the data registers (see Figure in Section 8 of the MPU-6000/MPU-6050 Product Specification document).

The high pass filter has three modes: 

- Reset:  The filter output settles to zero within one sample. This effectively disables the high pass filter. This mode may be toggled to quickly settle the filter.
- On:  The high pass filter will pass signals above the cut off frequency.
- Hold:  When triggered, the filter holds the present sample. The filter output will be the difference between the input sample and the held sample.

ACCEL_HPF Filter Mode Cut-off Frequency
0 Reset None
1 On 5Hz
2 On 2.5Hz
3 On 1.25Hz
4 On 0.63Hz
7 Hold None]]></Description>
            </Option>
            <Option>
              <Value>3</Value>
              <Format>3</Format>
              <Name><![CDATA[On @ 1.25 Hz]]></Name>
              <Description><![CDATA[3-bit unsigned value. Selects the Digital High Pass Filter configuration.

ACCEL_HPF configures the DHPF available in the path leading to motion detectors (Free Fall, Motion threshold, and Zero Motion). The high pass filter output is not available to the data registers (see Figure in Section 8 of the MPU-6000/MPU-6050 Product Specification document).

The high pass filter has three modes: 

- Reset:  The filter output settles to zero within one sample. This effectively disables the high pass filter. This mode may be toggled to quickly settle the filter.
- On:  The high pass filter will pass signals above the cut off frequency.
- Hold:  When triggered, the filter holds the present sample. The filter output will be the difference between the input sample and the held sample.

ACCEL_HPF Filter Mode Cut-off Frequency
0 Reset None
1 On 5Hz
2 On 2.5Hz
3 On 1.25Hz
4 On 0.63Hz
7 Hold None]]></Description>
            </Option>
            <Option>
              <Value>4</Value>
              <Format>3</Format>
              <Name><![CDATA[On @ 0.63 Hz]]></Name>
              <Description><![CDATA[3-bit unsigned value. Selects the Digital High Pass Filter configuration.

ACCEL_HPF configures the DHPF available in the path leading to motion detectors (Free Fall, Motion threshold, and Zero Motion). The high pass filter output is not available to the data registers (see Figure in Section 8 of the MPU-6000/MPU-6050 Product Specification document).

The high pass filter has three modes: 

- Reset:  The filter output settles to zero within one sample. This effectively disables the high pass filter. This mode may be toggled to quickly settle the filter.
- On:  The high pass filter will pass signals above the cut off frequency.
- Hold:  When triggered, the filter holds the present sample. The filter output will be the difference between the input sample and the held sample.

ACCEL_HPF Filter Mode Cut-off Frequency
0 Reset None
1 On 5Hz
2 On 2.5Hz
3 On 1.25Hz
4 On 0.63Hz
7 Hold None]]></Description>
            </Option>
            <Option>
              <Value>7</Value>
              <Format>3</Format>
              <Name><![CDATA[Hold]]></Name>
              <Description><![CDATA[3-bit unsigned value. Selects the Digital High Pass Filter configuration.

ACCEL_HPF configures the DHPF available in the path leading to motion detectors (Free Fall, Motion threshold, and Zero Motion). The high pass filter output is not available to the data registers (see Figure in Section 8 of the MPU-6000/MPU-6050 Product Specification document).

The high pass filter has three modes: 

- Reset:  The filter output settles to zero within one sample. This effectively disables the high pass filter. This mode may be toggled to quickly settle the filter.
- On:  The high pass filter will pass signals above the cut off frequency.
- Hold:  When triggered, the filter holds the present sample. The filter output will be the difference between the input sample and the held sample.

ACCEL_HPF Filter Mode Cut-off Frequency
0 Reset None
1 On 5Hz
2 On 2.5Hz
3 On 1.25Hz
4 On 0.63Hz
7 Hold None]]></Description>
            </Option>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>29</Address>
      <ShortName><![CDATA[FF_THR]]></ShortName>
      <Name><![CDATA[Free Fall Acceleration Threshold]]></Name>
      <Description><![CDATA[This register configures  the detection threshold for  Free Fall event detection.  The  mg per LSB increment for FF_THR can be found  in the Electrical Specifications table of the MPU-6000/MPU-6050 Product Specification document.

Free Fall is detected when the absolute value of the accelerometer measurements for the three axes 
are each less than the detection threshold. This condition increments the Free Fall duration counter 
(Register 30). The Free Fall interrupt is triggered when the Free Fall duration counter reaches the 
time specified in FF_DUR (Register 30).

For more details on the Free Fall detection interrupt,  see Section 8.2 of the MPU-6000/MPU-6050 
Product Specification document as well as Registers 56 and 58 of this document.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[FF_THR]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[8-bit unsigned value specifying the Free Fall detection threshold.]]></Description>
          <RW>0</RW>
          <DataType>uns</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>30</Address>
      <ShortName><![CDATA[FF_DUR]]></ShortName>
      <Name><![CDATA[Free Fall Duration]]></Name>
      <Description><![CDATA[This register configures  the duration counter threshold for Free  Fall event detection. The duration counter ticks at 1kHz, therefore FF_DUR has a unit of 1 LSB = 1 ms.

The Free Fall duration counter increments while the absolute value of the accelerometer measurements are each less than the detection threshold (Register 29). The Free Fall interrupt is triggered when the Free Fall duration counter reaches the time specified in this register. 

For more details on the Free Fall detection interrupt, see Section 8.2 of the MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and 58 of this document.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[FF_DUR]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[8-bit unsigned value. Specifies the duration counter threshold. Unit of LSB = 1ms.]]></Description>
          <RW>0</RW>
          <DataType>uns</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>31</Address>
      <ShortName><![CDATA[MOT_THR]]></ShortName>
      <Name><![CDATA[Motion Detection Threshold]]></Name>
      <Description><![CDATA[This register configures  the detection threshold for  Motion interrupt generation.  The mg per LSB increment for MOT_THR can be found in the Electrical Specifications table of the MPU-6000/MPU-6050 Product Specification document.

Motion is detected when the absolute value of any of the accelerometer measurements exceeds this Motion detection threshold. This condition increments the Motion detection duration counter (Register 32). The Motion detection interrupt is triggered when the Motion Detection counter reaches the time count specified in  MOT_DUR (Register 32).

The Motion interrupt will indicate the axis and  polarity of detected motion in MOT_DETECT_STATUS (Register 97).

For more details on the Motion detection interrupt, see  Section  8.3 of the MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and 58 of this document.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[MOT_THR]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[8-bit unsigned value. Specifies the Motion detection threshold.]]></Description>
          <RW>0</RW>
          <DataType>uns</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>32</Address>
      <ShortName><![CDATA[MOT_DUR]]></ShortName>
      <Name><![CDATA[Motion Detection Duration]]></Name>
      <Description><![CDATA[This register configures the duration counter threshold for Motion interrupt generation. The duration counter ticks at 1 kHz, therefore MOT_DUR has a unit of 1 LSB = 1 ms.

The Motion detection duration counter increments when the absolute value of any of the accelerometer measurements exceeds the Motion detection threshold (Register 31). The Motion detection interrupt is triggered when the Motion detection counter reaches the time count specified in this register. 

For more details on the Motion detection interrupt, see  Section 8.3 of the MPU-6000/MPU-6050 Product Specification document]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[MOT_DUR]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[8-bit unsigned value. Specifies the duration counter threshold. Unit of 1 LSB = 1ms.]]></Description>
          <RW>0</RW>
          <DataType>uns</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>33</Address>
      <ShortName><![CDATA[ZRMOT_THR]]></ShortName>
      <Name><![CDATA[Zero Motion Detection Threshold]]></Name>
      <Description><![CDATA[This register configures the detection threshold for Zero Motion interrupt generation. The mg per LSB increment for ZRMOT_THR can be found in the Electrical Specifications table of the MPU-6000/MPU-6050 Product Specification document.

Zero Motion is detected when the absolute value of the accelerometer measurements for the 3 axes are each less than the detection threshold. This condition increments the Zero Motion duration counter (Register 34). The Zero Motion interrupt is triggered when the Zero Motion duration counter reaches the time count specified in ZRMOT_DUR (Register 34).

Unlike Free Fall or Motion detection, Zero Motion detection triggers an interrupt both when Zero Motion is first detected and when Zero Motion is no longer detected.

When a zero motion event is detected, a Zero Motion Status will be indicated in the MOT_DETECT_STATUS register (Register 97). When a motion-to-zero-motion condition is detected, the status bit is set to 1. When a zero-motion-to-motion condition is detected, the status bit is set to 0.

For more details on the Zero Motion detection interrupt, see Section 8.4 of the MPU-6000/MPU-6050 Product Specification document as well as Registers 56 and 58 of this document.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[ZRMOT_THR]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[8-bit unsigned value. Specifies the Zero Motion detection threshold.]]></Description>
          <RW>0</RW>
          <DataType>uns</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>34</Address>
      <ShortName><![CDATA[ZRMOT_DUR]]></ShortName>
      <Name><![CDATA[Zero Motion Detection Duration]]></Name>
      <Description><![CDATA[This register configures the duration counter threshold for Zero Motion interrupt generation. The duration counter ticks at 16 Hz, therefore ZRMOT_DUR has a unit of 1 LSB = 64 ms.

The Zero Motion duration counter increments while the absolute value of the accelerometer measurements are each less than the detection threshold (Register 33). The Zero Motion interrupt is triggered when the Zero Motion duration counter reaches the time count specified in this register.

For more details on the Zero Motion detection interrupt, see Section 8.4 of the MPU-6000/MPU-6050 Product Specification document, as well as Registers 56 and 58 of this document.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[ZRMOT_DUR]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[8-bit unsigned value. Specifies the duration counter threshold. Unit of 1 LSB = 64ms.]]></Description>
          <RW>0</RW>
          <DataType>uns</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>35</Address>
      <ShortName><![CDATA[FIFO_EN]]></ShortName>
      <Name><![CDATA[FIFO Enable]]></Name>
      <Description><![CDATA[This register determines which sensor measurements are loaded into the FIFO buffer.

Data stored inside the sensor data registers (Registers 59 to 96) will be loaded into the FIFO buffer if a sensor’s respective FIFO_EN bit is set to 1 in this register.

When a sensor’s FIFO_EN bit is enabled in this register, data from the sensor data registers will be loaded into the FIFO buffer. The sensors are sampled at the Sample Rate as defined in Register 25. For further information regarding sensor data registers, please refer to Registers 59 to 96.

When an external Slave’s corresponding FIFO_EN bit (SLVx_FIFO_EN, where x=0, 1, or 2) is set to 1, the data stored in its corresponding data registers (EXT_SENS_DATA registers, Registers 73 to 96) will be written into the FIFO buffer at the Sample Rate. EXT_SENS_DATA register association with I2C Slaves is determined by the I2C_SLVx_CTRL registers (where x=0, 1, or 2; Registers 39, 42, and 45). For information regarding EXT_SENS_DATA registers, please refer to Registers 73 to 96.

Note that the corresponding FIFO_EN bit (SLV3_FIFO_EN) is found in I2C_MST_CTRL (Register 36). Also note that Slave 4 behaves in a different manner compared to Slaves 0-3. Please refer to Registers 49 to 53 for further information regarding Slave 4 usage.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[TEMP_FIFO_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit enables TEMP_OUT_H and TEMP_OUT_L (Registers 65 and 66) to be written into the FIFO buffer.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>6</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[XG_FIFO_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit enables GYRO_XOUT_H and GYRO_XOUT_L (Registers 67 and 68) to be written into the FIFO buffer.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>5</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[YG_FIFO_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit enables GYRO_YOUT_H and GYRO_YOUT_L (Registers 69 and 70) to be written into the FIFO buffer.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>4</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[ZG_FIFO_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit enables GYRO_ZOUT_H and GYRO_ZOUT_L (Registers 71 and 72) to be written into the FIFO buffer.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>3</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[ACCEL_FIFO_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit enables ACCEL_XOUT_H, ACCEL_XOUT_L, ACCEL_YOUT_H, ACCEL_YOUT_L, ACCEL_ZOUT_H, and ACCEL_ZOUT_L (Registers 59 to 64) to be written into the FIFO buffer.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>2</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[SLV2_FIFO_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 2 to be written into the FIFO buffer.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>1</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[SLV1_FIFO_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 1 to be written into the FIFO buffer.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>0</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[SLV0_FIFO_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit enables EXT_SENS_DATA registers (Registers 73 to 96) associated with Slave 0 to be written into the FIFO buffer.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>36</Address>
      <ShortName><![CDATA[I2C_MST_CTRL]]></ShortName>
      <Name><![CDATA[I2C Master Control]]></Name>
      <Description><![CDATA[This register configures the auxiliary I2C bus for single-master or multi-master control. In addition, the register is used to delay the Data Ready interrupt, and also enables the writing of Slave 3 data into the FIFO buffer. The register also configures the auxiliary I2C Master’s transition from one slave read to the next, as well as the MPU-60X0’s 8MHz internal clock.

Multi-master capability allows multiple I2C masters to operate on the same bus. In circuits where multi-master capability is required, set MULT_MST_EN to 1. This will increase current drawn by approximately 30μA.

In circuits where multi-master capability is required, the state of the I2C bus must always be monitored by each separate I2C Master. Before an I2C Master can assume arbitration of the bus, it must first confirm that no other I2C Master has arbitration of the bus. When MULT_MST_EN is set to 1, the MPU-60X0’s bus arbitration detection logic is turned on, enabling it to detect when the bus is available.

When the WAIT_FOR_ES bit is set to 1, the Data Ready interrupt will be delayed until External Sensor data from the Slave Devices are loaded into the EXT_SENS_DATA registers. This is used to ensure that both the internal sensor data (i.e. from gyro and accel) and external sensor data have been loaded to their respective data registers (i.e. the data is synced) when the Data Ready interrupt is triggered.

When the Slave 3 FIFO enable bit (SLV_3_FIFO_EN) is set to 1, Slave 3 sensor measurement data will be loaded into the FIFO buffer each time. EXT_SENS_DATA register association with I2C Slaves is determined by I2C_SLV3_CTRL (Register 48).

For further information regarding EXT_SENS_DATA registers, please refer to Registers 73 to 96.

The corresponding FIFO_EN bits for Slave 0, Slave 1, and Slave 2 can be found in Register 35.

The I2C_MST_P_NSR bit configures the I2C Master’s transition from one slave read to the next slave read. If the bit equals 0, there will be a restart between reads. If the bit equals 1, there will be a stop followed by a start of the following read. When a write transaction follows a read transaction, the stop followed by a start of the successive write will be always used.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[MULT_MST_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit enables multi-master capability.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>6</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[WAIT_FOR_ES]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit delays the Data Ready interrupt until External Sensor data from the Slave devices have been loaded into the EXT_SENS_DATA registers.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>5</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[SLV_3_FIFO_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit enables EXT_SENS_DATA registers associated with Slave 3 to be written into the FIFO. The corresponding bits for Slaves 0-2 can be found in Register 35.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>4</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_MST_P_NSR]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Controls the I2C Master’s transition from one slave read to the next slave read.

When this bit equals 0, there is a restart between reads.
When this bit equals 1, there is a stop and start marking the beginning of the next read.

When a write follows a read, a stop and start is always enforced.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>3</StartBit>
          <BitLength>4</BitLength>
          <ShortName><![CDATA[I2C_MST_CLK]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[I2C_MST_CLK is a 4 bit unsigned value which configures a divider on the MPU-60X0 internal 8MHz clock. It sets the I2C master clock speed according to the following table:

I2C_MST_CLK I2C Master Clock Speed 8MHz Clock Divider
0 348 kHz 23
1 333 kHz 24
2 320 kHz 25
3 308 kHz 26
4 296 kHz 27
5 286 kHz 28
6 276 kHz 29
7 267 kHz 30
8 258 kHz 31
9 500 kHz 16
10 471 kHz 17
11 444 kHz 18
12 421 kHz 19
13 400 kHz 20
14 381 kHz 21
15 364 kHz 22]]></Description>
          <RW>0</RW>
          <DataType>set</DataType>
          <Options>
            <Option>
              <Value>0</Value>
              <Format>4</Format>
              <Name><![CDATA[348 kHz / 23]]></Name>
              <Description><![CDATA[I2C_MST_CLK is a 4 bit unsigned value which configures a divider on the MPU-60X0 internal 8MHz clock. It sets the I2C master clock speed according to the following table:

I2C_MST_CLK I2C Master Clock Speed 8MHz Clock Divider
0 348 kHz 23
1 333 kHz 24
2 320 kHz 25
3 308 kHz 26
4 296 kHz 27
5 286 kHz 28
6 276 kHz 29
7 267 kHz 30
8 258 kHz 31
9 500 kHz 16
10 471 kHz 17
11 444 kHz 18
12 421 kHz 19
13 400 kHz 20
14 381 kHz 21
15 364 kHz 22]]></Description>
            </Option>
            <Option>
              <Value>1</Value>
              <Format>4</Format>
              <Name><![CDATA[333 kHz / 24]]></Name>
              <Description><![CDATA[I2C_MST_CLK is a 4 bit unsigned value which configures a divider on the MPU-60X0 internal 8MHz clock. It sets the I2C master clock speed according to the following table:

I2C_MST_CLK I2C Master Clock Speed 8MHz Clock Divider
0 348 kHz 23
1 333 kHz 24
2 320 kHz 25
3 308 kHz 26
4 296 kHz 27
5 286 kHz 28
6 276 kHz 29
7 267 kHz 30
8 258 kHz 31
9 500 kHz 16
10 471 kHz 17
11 444 kHz 18
12 421 kHz 19
13 400 kHz 20
14 381 kHz 21
15 364 kHz 22]]></Description>
            </Option>
            <Option>
              <Value>2</Value>
              <Format>4</Format>
              <Name><![CDATA[320 kHz / 25]]></Name>
              <Description><![CDATA[I2C_MST_CLK is a 4 bit unsigned value which configures a divider on the MPU-60X0 internal 8MHz clock. It sets the I2C master clock speed according to the following table:

I2C_MST_CLK I2C Master Clock Speed 8MHz Clock Divider
0 348 kHz 23
1 333 kHz 24
2 320 kHz 25
3 308 kHz 26
4 296 kHz 27
5 286 kHz 28
6 276 kHz 29
7 267 kHz 30
8 258 kHz 31
9 500 kHz 16
10 471 kHz 17
11 444 kHz 18
12 421 kHz 19
13 400 kHz 20
14 381 kHz 21
15 364 kHz 22]]></Description>
            </Option>
            <Option>
              <Value>3</Value>
              <Format>4</Format>
              <Name><![CDATA[308 kHz / 26]]></Name>
              <Description><![CDATA[I2C_MST_CLK is a 4 bit unsigned value which configures a divider on the MPU-60X0 internal 8MHz clock. It sets the I2C master clock speed according to the following table:

I2C_MST_CLK I2C Master Clock Speed 8MHz Clock Divider
0 348 kHz 23
1 333 kHz 24
2 320 kHz 25
3 308 kHz 26
4 296 kHz 27
5 286 kHz 28
6 276 kHz 29
7 267 kHz 30
8 258 kHz 31
9 500 kHz 16
10 471 kHz 17
11 444 kHz 18
12 421 kHz 19
13 400 kHz 20
14 381 kHz 21
15 364 kHz 22]]></Description>
            </Option>
            <Option>
              <Value>4</Value>
              <Format>4</Format>
              <Name><![CDATA[296 kHz / 27]]></Name>
              <Description><![CDATA[I2C_MST_CLK is a 4 bit unsigned value which configures a divider on the MPU-60X0 internal 8MHz clock. It sets the I2C master clock speed according to the following table:

I2C_MST_CLK I2C Master Clock Speed 8MHz Clock Divider
0 348 kHz 23
1 333 kHz 24
2 320 kHz 25
3 308 kHz 26
4 296 kHz 27
5 286 kHz 28
6 276 kHz 29
7 267 kHz 30
8 258 kHz 31
9 500 kHz 16
10 471 kHz 17
11 444 kHz 18
12 421 kHz 19
13 400 kHz 20
14 381 kHz 21
15 364 kHz 22]]></Description>
            </Option>
            <Option>
              <Value>5</Value>
              <Format>4</Format>
              <Name><![CDATA[286 kHz / 28]]></Name>
              <Description><![CDATA[I2C_MST_CLK is a 4 bit unsigned value which configures a divider on the MPU-60X0 internal 8MHz clock. It sets the I2C master clock speed according to the following table:

I2C_MST_CLK I2C Master Clock Speed 8MHz Clock Divider
0 348 kHz 23
1 333 kHz 24
2 320 kHz 25
3 308 kHz 26
4 296 kHz 27
5 286 kHz 28
6 276 kHz 29
7 267 kHz 30
8 258 kHz 31
9 500 kHz 16
10 471 kHz 17
11 444 kHz 18
12 421 kHz 19
13 400 kHz 20
14 381 kHz 21
15 364 kHz 22]]></Description>
            </Option>
            <Option>
              <Value>6</Value>
              <Format>4</Format>
              <Name><![CDATA[276 kHz / 29]]></Name>
              <Description><![CDATA[I2C_MST_CLK is a 4 bit unsigned value which configures a divider on the MPU-60X0 internal 8MHz clock. It sets the I2C master clock speed according to the following table:

I2C_MST_CLK I2C Master Clock Speed 8MHz Clock Divider
0 348 kHz 23
1 333 kHz 24
2 320 kHz 25
3 308 kHz 26
4 296 kHz 27
5 286 kHz 28
6 276 kHz 29
7 267 kHz 30
8 258 kHz 31
9 500 kHz 16
10 471 kHz 17
11 444 kHz 18
12 421 kHz 19
13 400 kHz 20
14 381 kHz 21
15 364 kHz 22]]></Description>
            </Option>
            <Option>
              <Value>7</Value>
              <Format>4</Format>
              <Name><![CDATA[267 kHz / 30]]></Name>
              <Description><![CDATA[I2C_MST_CLK is a 4 bit unsigned value which configures a divider on the MPU-60X0 internal 8MHz clock. It sets the I2C master clock speed according to the following table:

I2C_MST_CLK I2C Master Clock Speed 8MHz Clock Divider
0 348 kHz 23
1 333 kHz 24
2 320 kHz 25
3 308 kHz 26
4 296 kHz 27
5 286 kHz 28
6 276 kHz 29
7 267 kHz 30
8 258 kHz 31
9 500 kHz 16
10 471 kHz 17
11 444 kHz 18
12 421 kHz 19
13 400 kHz 20
14 381 kHz 21
15 364 kHz 22]]></Description>
            </Option>
            <Option>
              <Value>8</Value>
              <Format>4</Format>
              <Name><![CDATA[258 kHz / 31]]></Name>
              <Description><![CDATA[I2C_MST_CLK is a 4 bit unsigned value which configures a divider on the MPU-60X0 internal 8MHz clock. It sets the I2C master clock speed according to the following table:

I2C_MST_CLK I2C Master Clock Speed 8MHz Clock Divider
0 348 kHz 23
1 333 kHz 24
2 320 kHz 25
3 308 kHz 26
4 296 kHz 27
5 286 kHz 28
6 276 kHz 29
7 267 kHz 30
8 258 kHz 31
9 500 kHz 16
10 471 kHz 17
11 444 kHz 18
12 421 kHz 19
13 400 kHz 20
14 381 kHz 21
15 364 kHz 22]]></Description>
            </Option>
            <Option>
              <Value>9</Value>
              <Format>4</Format>
              <Name><![CDATA[500 kHz / 16]]></Name>
              <Description><![CDATA[I2C_MST_CLK is a 4 bit unsigned value which configures a divider on the MPU-60X0 internal 8MHz clock. It sets the I2C master clock speed according to the following table:

I2C_MST_CLK I2C Master Clock Speed 8MHz Clock Divider
0 348 kHz 23
1 333 kHz 24
2 320 kHz 25
3 308 kHz 26
4 296 kHz 27
5 286 kHz 28
6 276 kHz 29
7 267 kHz 30
8 258 kHz 31
9 500 kHz 16
10 471 kHz 17
11 444 kHz 18
12 421 kHz 19
13 400 kHz 20
14 381 kHz 21
15 364 kHz 22]]></Description>
            </Option>
            <Option>
              <Value>10</Value>
              <Format>4</Format>
              <Name><![CDATA[471 kHz / 17]]></Name>
              <Description><![CDATA[I2C_MST_CLK is a 4 bit unsigned value which configures a divider on the MPU-60X0 internal 8MHz clock. It sets the I2C master clock speed according to the following table:

I2C_MST_CLK I2C Master Clock Speed 8MHz Clock Divider
0 348 kHz 23
1 333 kHz 24
2 320 kHz 25
3 308 kHz 26
4 296 kHz 27
5 286 kHz 28
6 276 kHz 29
7 267 kHz 30
8 258 kHz 31
9 500 kHz 16
10 471 kHz 17
11 444 kHz 18
12 421 kHz 19
13 400 kHz 20
14 381 kHz 21
15 364 kHz 22]]></Description>
            </Option>
            <Option>
              <Value>11</Value>
              <Format>4</Format>
              <Name><![CDATA[444 kHz / 18]]></Name>
              <Description><![CDATA[I2C_MST_CLK is a 4 bit unsigned value which configures a divider on the MPU-60X0 internal 8MHz clock. It sets the I2C master clock speed according to the following table:

I2C_MST_CLK I2C Master Clock Speed 8MHz Clock Divider
0 348 kHz 23
1 333 kHz 24
2 320 kHz 25
3 308 kHz 26
4 296 kHz 27
5 286 kHz 28
6 276 kHz 29
7 267 kHz 30
8 258 kHz 31
9 500 kHz 16
10 471 kHz 17
11 444 kHz 18
12 421 kHz 19
13 400 kHz 20
14 381 kHz 21
15 364 kHz 22]]></Description>
            </Option>
            <Option>
              <Value>12</Value>
              <Format>4</Format>
              <Name><![CDATA[421 kHz / 19]]></Name>
              <Description><![CDATA[I2C_MST_CLK is a 4 bit unsigned value which configures a divider on the MPU-60X0 internal 8MHz clock. It sets the I2C master clock speed according to the following table:

I2C_MST_CLK I2C Master Clock Speed 8MHz Clock Divider
0 348 kHz 23
1 333 kHz 24
2 320 kHz 25
3 308 kHz 26
4 296 kHz 27
5 286 kHz 28
6 276 kHz 29
7 267 kHz 30
8 258 kHz 31
9 500 kHz 16
10 471 kHz 17
11 444 kHz 18
12 421 kHz 19
13 400 kHz 20
14 381 kHz 21
15 364 kHz 22]]></Description>
            </Option>
            <Option>
              <Value>13</Value>
              <Format>4</Format>
              <Name><![CDATA[400 kHz / 20]]></Name>
              <Description><![CDATA[I2C_MST_CLK is a 4 bit unsigned value which configures a divider on the MPU-60X0 internal 8MHz clock. It sets the I2C master clock speed according to the following table:

I2C_MST_CLK I2C Master Clock Speed 8MHz Clock Divider
0 348 kHz 23
1 333 kHz 24
2 320 kHz 25
3 308 kHz 26
4 296 kHz 27
5 286 kHz 28
6 276 kHz 29
7 267 kHz 30
8 258 kHz 31
9 500 kHz 16
10 471 kHz 17
11 444 kHz 18
12 421 kHz 19
13 400 kHz 20
14 381 kHz 21
15 364 kHz 22]]></Description>
            </Option>
            <Option>
              <Value>14</Value>
              <Format>4</Format>
              <Name><![CDATA[381 kHz / 21]]></Name>
              <Description><![CDATA[I2C_MST_CLK is a 4 bit unsigned value which configures a divider on the MPU-60X0 internal 8MHz clock. It sets the I2C master clock speed according to the following table:

I2C_MST_CLK I2C Master Clock Speed 8MHz Clock Divider
0 348 kHz 23
1 333 kHz 24
2 320 kHz 25
3 308 kHz 26
4 296 kHz 27
5 286 kHz 28
6 276 kHz 29
7 267 kHz 30
8 258 kHz 31
9 500 kHz 16
10 471 kHz 17
11 444 kHz 18
12 421 kHz 19
13 400 kHz 20
14 381 kHz 21
15 364 kHz 22]]></Description>
            </Option>
            <Option>
              <Value>15</Value>
              <Format>4</Format>
              <Name><![CDATA[364 kHz / 22]]></Name>
              <Description><![CDATA[I2C_MST_CLK is a 4 bit unsigned value which configures a divider on the MPU-60X0 internal 8MHz clock. It sets the I2C master clock speed according to the following table:

I2C_MST_CLK I2C Master Clock Speed 8MHz Clock Divider
0 348 kHz 23
1 333 kHz 24
2 320 kHz 25
3 308 kHz 26
4 296 kHz 27
5 286 kHz 28
6 276 kHz 29
7 267 kHz 30
8 258 kHz 31
9 500 kHz 16
10 471 kHz 17
11 444 kHz 18
12 421 kHz 19
13 400 kHz 20
14 381 kHz 21
15 364 kHz 22]]></Description>
            </Option>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>37</Address>
      <ShortName><![CDATA[I2C_SLV0_ADDR]]></ShortName>
      <Name><![CDATA[I2C Slave 0 Address]]></Name>
      <Description><![CDATA[Configures the device address and data transfer mode for Slave 0. I2C data transactions are performed at the Sample Rate, as defined in Register 25. The user is responsible for ensuring that I2C data transactions to and from each enabled Slave can be completed within a single period of the Sample Rate.

The I2C slave access rate can be reduced relative to the Sample Rate. This reduced access rate is determined by I2C_MST_DLY (Register 52). Whether a slave’s access rate is reduced relative to the Sample Rate is determined by I2C_MST_DELAY_CTRL (Register 103).

The processing order for the slaves is fixed. The sequence followed for processing the slaves is Slave 0, Slave 1, Slave 2, Slave 3 and Slave 4. If a particular Slave is disabled it will be skipped.

Each slave can either be accessed at the sample rate or at a reduced sample rate. In a case where some slaves are accessed at the Sample Rate and some slaves are accessed at the reduced rate, the sequence of accessing the slaves (Slave 0 to Slave 4) is still followed. However, the reduced rate slaves will be skipped if their access rate dictates that they should not be accessed during that particular cycle. For further information regarding the reduced access rate, please refer to Register 52. Whether a slave is accessed at the Sample Rate or at the reduced rate is determined by the Delay Enable bits in Register 103.

Byte Swapping Example

The following example demonstrates byte swapping for I2C_SLV0_BYTE_SW = 1, I2C_SLV0_GRP = 0, I2C_SLV0_REG = 0x01, and I2C_SLV0_LEN = 0x4:

1. The first byte, read from Slave 0 register 0x01, will be stored at EXT_SENS_DATA_00. Because I2C_SLV0_GRP = 0, bytes from even, then odd register addresses will be paired together as word pairs. Since the read operation started from an odd register address instead of an even address, only one byte is read.

2. The second and third bytes will be swapped, since I2C_SLV0_BYTE_SW = 1 and I2C_SLV0_REG[0] = 1. The data read from 0x02 will be stored at EXT_SENS_DATA_02, and the data read from 0x03 will be stored at EXT_SENS_DATA_01.

3. The last byte, read from address 0x04, will be stored at EXT_SENS_DATA_03. Because there is only one byte remaining in the read operation, byte swapping will not occur.

Slave Access Example

Slave 0 is accessed at the Sample Rate, while Slave 1 is accessed at half the Sample Rate. The other slaves are disabled. In the first cycle, both Slave 0 and Slave 1 will be accessed. However, in the second cycle, only Slave 0 will be accessed. In the third cycle, both Slave 0 and Slave 1 will be accessed. In the fourth cycle, only Slave 0 will be accessed. This pattern continues.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV0_RW]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[I2C slave data transactions between the MPU-60X0 and Slave 0 are set as either read or write operations by the I2C_SLV0_RW bit. When this bit is 1, the transfer is a read operation. When the bit is 0, the transfer is a write operation.

In read mode, the result of the read is placed in the lowest available EXT_SENS_DATA register. For further information regarding the allocation of read results, please refer to the EXT_SENS_DATA register description (Registers 73 – 96). In write mode, the contents of I2C_SLV0_DO (Register 99) will be written to the slave device.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>6</StartBit>
          <BitLength>7</BitLength>
          <ShortName><![CDATA[I2C_SLV0_ADDR]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Specifies the 7-bit I2C slave address of Slave 0.]]></Description>
          <RW>0</RW>
          <DataType>uns</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>38</Address>
      <ShortName><![CDATA[I2C_SLV0_REG]]></ShortName>
      <Name><![CDATA[I2C Slave 0 Register]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[I2C_SLV0_REG]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Specifies the internal register at which to begin data transfer within Slave 0.]]></Description>
          <RW>0</RW>
          <DataType>uns</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>39</Address>
      <ShortName><![CDATA[I2C_SLV0_CTRL]]></ShortName>
      <Name><![CDATA[I2C Slave 0 Control]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV0_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Enables Slave 0 for I2C data transaction. A data transaction is performed only if more than zero bytes are to be transferred (I2C_SLV0_LEN &gt; 0) between an enabled slave device (I2C_SLV0_EN = 1).]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>6</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV0_BYTE_SW]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Configures byte swapping of word pairs. When byte swapping is enabled, the high and low bytes of a word pair are swapped. Please refer to I2C_SLV0_GRP for the pairing convention of the word pairs. When this bit is cleared to 0, bytes transferred to and from Slave 0 will be written to EXT_SENS_DATA registers in the order they were transferred.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>5</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV0_REG_DIS]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Disable slave register address sending. When set to 1, the transaction will read or write data only. When cleared to 0, the transaction will write a register address prior to reading or writing data. This bit should equal 0 when specifying the register address within the Slave device to/from which the ensuing data transaction will take place.]]></Description>
          <RW>0</RW>
          <DataType>dis</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>4</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV0_GRP]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Specifies the grouping order of word pairs received from registers. When cleared to 0, bytes from register addresses 0 and 1, 2 and 3, etc (even, then odd register addresses) are paired to form a word. When set to 1, bytes from register addresses are paired 1 and 2, 3 and 4, etc. (odd, then even register addresses) are paired to form a word.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>3</StartBit>
          <BitLength>4</BitLength>
          <ShortName><![CDATA[I2C_SLV0_LEN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[The number of bytes transferred is specified by I2C_SLV0_LEN. When more than 1 byte is transferred (I2C_SLV0_LEN &gt; 1), data is read from (written to) sequential addresses starting from I2C_SLV0_REG.]]></Description>
          <RW>0</RW>
          <DataType>uns</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>40</Address>
      <ShortName><![CDATA[I2C_SLV1_ADDR]]></ShortName>
      <Name><![CDATA[I2C Slave 1 Address]]></Name>
      <Description><![CDATA[Configures the device address and data transfer mode for Slave 1. I2C data transactions are performed at the Sample Rate, as defined in Register 25. The user is responsible for ensuring that I2C data transactions to and from each enabled Slave can be completed within a single period of the Sample Rate.

The I2C slave access rate can be reduced relative to the Sample Rate. This reduced access rate is determined by I2C_MST_DLY (Register 52). Whether a slave’s access rate is reduced relative to the Sample Rate is determined by I2C_MST_DELAY_CTRL (Register 103).

The processing order for the slaves is fixed. The sequence followed for processing the slaves is Slave 0, Slave 1, Slave 2, Slave 3 and Slave 4. If a particular Slave is disabled it will be skipped.

Each slave can either be accessed at the sample rate or at a reduced sample rate. In a case where some slaves are accessed at the Sample Rate and some slaves are accessed at the reduced rate, the sequence of accessing the slaves (Slave 0 to Slave 4) is still followed. However, the reduced rate slaves will be skipped if their access rate dictates that they should not be accessed during that particular cycle. For further information regarding the reduced access rate, please refer to Register 52. Whether a slave is accessed at the Sample Rate or at the reduced rate is determined by the Delay Enable bits in Register 103.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV1_RW]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[I2C slave data transactions between the MPU-60X0 and Slave 1 are set as either read or write operations by the I2C_SLV1_RW bit. When this bit is 1, the transfer is a read operation. When the bit is 0, the transfer is a write operation.

In read mode, the result of the read is placed in the lowest available EXT_SENS_DATA register. For further information regarding the allocation of read results, please refer to the EXT_SENS_DATA register description (Registers 73 – 96). In write mode, the contents of I2C_SLV1_DO (Register 99) will be written to the slave device.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>6</StartBit>
          <BitLength>7</BitLength>
          <ShortName><![CDATA[I2C_SLV1_ADDR]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Specifies the 7-bit I2C slave address of Slave 1.]]></Description>
          <RW>0</RW>
          <DataType>uns</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>41</Address>
      <ShortName><![CDATA[I2C_SLV1_REG]]></ShortName>
      <Name><![CDATA[I2C Slave 1 Register]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[I2C_SLV1_REG]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Specifies the internal register at which to begin data transfer within Slave 1.]]></Description>
          <RW>0</RW>
          <DataType>uns</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>42</Address>
      <ShortName><![CDATA[I2C_SLV1_CTRL]]></ShortName>
      <Name><![CDATA[I2C Slave 1 Control]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV1_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Enables Slave 1 for I2C data transaction. A data transaction is performed only if more than zero bytes are to be transferred (I2C_SLV1_LEN &gt; 0) between an enabled slave device (I2C_SLV1_EN = 1).]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>6</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV1_BYTE_SW]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Configures byte swapping of word pairs. When byte swapping is enabled, the high and low bytes of a word pair are swapped. Please refer to I2C_SLV1_GRP for the pairing convention of the word pairs. When this bit is cleared to 0, bytes transferred to and from Slave 1 will be written to EXT_SENS_DATA registers in the order they were transferred.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>5</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV1_REG_DIS]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Disable slave register address sending. When set to 1, the transaction will read or write data only. When cleared to 0, the transaction will write a register address prior to reading or writing data. This bit should equal 0 when specifying the register address within the Slave device to/from which the ensuing data transaction will take place.]]></Description>
          <RW>0</RW>
          <DataType>dis</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>4</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV1_GRP]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Specifies the grouping order of word pairs received from registers. When cleared to 0, bytes from register addresses 0 and 1, 2 and 3, etc (even, then odd register addresses) are paired to form a word. When set to 1, bytes from register addresses are paired 1 and 2, 3 and 4, etc. (odd, then even register addresses) are paired to form a word.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>3</StartBit>
          <BitLength>4</BitLength>
          <ShortName><![CDATA[I2C_SLV1_LEN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[The number of bytes transferred is specified by I2C_SLV1_LEN. When more than 1 byte is transferred (I2C_SLV1_LEN &gt; 1), data is read from (written to) sequential addresses starting from I2C_SLV1_REG.]]></Description>
          <RW>0</RW>
          <DataType>uns</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>43</Address>
      <ShortName><![CDATA[I2C_SLV2_ADDR]]></ShortName>
      <Name><![CDATA[I2C Slave 2 Address]]></Name>
      <Description><![CDATA[Configures the device address and data transfer mode for Slave 2. I2C data transactions are performed at the Sample Rate, as defined in Register 25. The user is responsible for ensuring that I2C data transactions to and from each enabled Slave can be completed within a single period of the Sample Rate.

The I2C slave access rate can be reduced relative to the Sample Rate. This reduced access rate is determined by I2C_MST_DLY (Register 52). Whether a slave’s access rate is reduced relative to the Sample Rate is determined by I2C_MST_DELAY_CTRL (Register 103).

The processing order for the slaves is fixed. The sequence followed for processing the slaves is Slave 0, Slave 1, Slave 2, Slave 3 and Slave 4. If a particular Slave is disabled it will be skipped.

Each slave can either be accessed at the sample rate or at a reduced sample rate. In a case where some slaves are accessed at the Sample Rate and some slaves are accessed at the reduced rate, the sequence of accessing the slaves (Slave 0 to Slave 4) is still followed. However, the reduced rate slaves will be skipped if their access rate dictates that they should not be accessed during that particular cycle. For further information regarding the reduced access rate, please refer to Register 52. Whether a slave is accessed at the Sample Rate or at the reduced rate is determined by the Delay Enable bits in Register 103.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV2_RW]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[I2C slave data transactions between the MPU-60X0 and Slave 2 are set as either read or write operations by the I2C_SLV2_RW bit. When this bit is 1, the transfer is a read operation. When the bit is 0, the transfer is a write operation.

In read mode, the result of the read is placed in the lowest available EXT_SENS_DATA register. For further information regarding the allocation of read results, please refer to the EXT_SENS_DATA register description (Registers 73 – 96). In write mode, the contents of I2C_SLV2_DO (Register 99) will be written to the slave device.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>6</StartBit>
          <BitLength>7</BitLength>
          <ShortName><![CDATA[I2C_SLV2_ADDR]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Specifies the 7-bit I2C slave address of Slave 2.]]></Description>
          <RW>0</RW>
          <DataType>uns</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>44</Address>
      <ShortName><![CDATA[I2C_SLV2_REG]]></ShortName>
      <Name><![CDATA[I2C Slave 2 Register]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[I2C_SLV2_REG]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Specifies the internal register at which to begin data transfer within Slave 2.]]></Description>
          <RW>0</RW>
          <DataType>uns</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>45</Address>
      <ShortName><![CDATA[I2C_SLV2_CTRL]]></ShortName>
      <Name><![CDATA[I2C Slave 2 Control]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV2_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Enables Slave 2 for I2C data transaction. A data transaction is performed only if more than zero bytes are to be transferred (I2C_SLV2_LEN &gt; 0) between an enabled slave device (I2C_SLV2_EN = 1).]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>6</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV2_BYTE_SW]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Configures byte swapping of word pairs. When byte swapping is enabled, the high and low bytes of a word pair are swapped. Please refer to I2C_SLV2_GRP for the pairing convention of the word pairs. When this bit is cleared to 0, bytes transferred to and from Slave 2 will be written to EXT_SENS_DATA registers in the order they were transferred.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>5</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV2_REG_DIS]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Disable slave register address sending. When set to 1, the transaction will read or write data only. When cleared to 0, the transaction will write a register address prior to reading or writing data. This bit should equal 0 when specifying the register address within the Slave device to/from which the ensuing data transaction will take place.]]></Description>
          <RW>0</RW>
          <DataType>dis</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>4</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV2_GRP]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Specifies the grouping order of word pairs received from registers. When cleared to 0, bytes from register addresses 0 and 1, 2 and 3, etc (even, then odd register addresses) are paired to form a word. When set to 1, bytes from register addresses are paired 1 and 2, 3 and 4, etc. (odd, then even register addresses) are paired to form a word.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>3</StartBit>
          <BitLength>4</BitLength>
          <ShortName><![CDATA[I2C_SLV2_LEN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[The number of bytes transferred is specified by I2C_SLV2_LEN. When more than 1 byte is transferred (I2C_SLV2_LEN &gt; 1), data is read from (written to) sequential addresses starting from I2C_SLV2_REG.]]></Description>
          <RW>0</RW>
          <DataType>uns</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>46</Address>
      <ShortName><![CDATA[I2C_SLV3_ADDR]]></ShortName>
      <Name><![CDATA[I2C Slave 3 Address]]></Name>
      <Description><![CDATA[Configures the device address and data transfer mode for Slave 3. I2C data transactions are performed at the Sample Rate, as defined in Register 25. The user is responsible for ensuring that I2C data transactions to and from each enabled Slave can be completed within a single period of the Sample Rate.

The I2C slave access rate can be reduced relative to the Sample Rate. This reduced access rate is determined by I2C_MST_DLY (Register 52). Whether a slave’s access rate is reduced relative to the Sample Rate is determined by I2C_MST_DELAY_CTRL (Register 103).

The processing order for the slaves is fixed. The sequence followed for processing the slaves is Slave 0, Slave 1, Slave 2, Slave 3 and Slave 4. If a particular Slave is disabled it will be skipped.

Each slave can either be accessed at the sample rate or at a reduced sample rate. In a case where some slaves are accessed at the Sample Rate and some slaves are accessed at the reduced rate, the sequence of accessing the slaves (Slave 0 to Slave 4) is still followed. However, the reduced rate slaves will be skipped if their access rate dictates that they should not be accessed during that particular cycle. For further information regarding the reduced access rate, please refer to Register 52. Whether a slave is accessed at the Sample Rate or at the reduced rate is determined by the Delay Enable bits in Register 103.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV3_RW]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[I2C slave data transactions between the MPU-60X0 and Slave 3 are set as either read or write operations by the I2C_SLV3_RW bit. When this bit is 1, the transfer is a read operation. When the bit is 0, the transfer is a write operation.

In read mode, the result of the read is placed in the lowest available EXT_SENS_DATA register. For further information regarding the allocation of read results, please refer to the EXT_SENS_DATA register description (Registers 73 – 96). In write mode, the contents of I2C_SLV3_DO (Register 99) will be written to the slave device.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>6</StartBit>
          <BitLength>7</BitLength>
          <ShortName><![CDATA[I2C_SLV3_ADDR]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Specifies the 7-bit I2C slave address of Slave 3.]]></Description>
          <RW>0</RW>
          <DataType>uns</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>47</Address>
      <ShortName><![CDATA[I2C_SLV3_REG]]></ShortName>
      <Name><![CDATA[I2C Slave 3 Register]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[I2C_SLV3_REG]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Specifies the internal register at which to begin data transfer within Slave 3.]]></Description>
          <RW>0</RW>
          <DataType>uns</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>48</Address>
      <ShortName><![CDATA[I2C_SLV3_CTRL]]></ShortName>
      <Name><![CDATA[I2C Slave 3 Control]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV3_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Enables Slave 3 for I2C data transaction. A data transaction is performed only if more than zero bytes are to be transferred (I2C_SLV3_LEN &gt; 0) between an enabled slave device (I2C_SLV3_EN = 1).]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>6</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV3_BYTE_SW]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Configures byte swapping of word pairs. When byte swapping is enabled, the high and low bytes of a word pair are swapped. Please refer to I2C_SLV3_GRP for the pairing convention of the word pairs. When this bit is cleared to 0, bytes transferred to and from Slave 3 will be written to EXT_SENS_DATA registers in the order they were transferred.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>5</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV3_REG_DIS]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Disable slave register address sending. When set to 1, the transaction will read or write data only. When cleared to 0, the transaction will write a register address prior to reading or writing data. This bit should equal 0 when specifying the register address within the Slave device to/from which the ensuing data transaction will take place.]]></Description>
          <RW>0</RW>
          <DataType>dis</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>4</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV3_GRP]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Specifies the grouping order of word pairs received from registers. When cleared to 0, bytes from register addresses 0 and 1, 2 and 3, etc (even, then odd register addresses) are paired to form a word. When set to 1, bytes from register addresses are paired 1 and 2, 3 and 4, etc. (odd, then even register addresses) are paired to form a word.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>3</StartBit>
          <BitLength>4</BitLength>
          <ShortName><![CDATA[I2C_SLV3_LEN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[The number of bytes transferred is specified by I2C_SLV3_LEN. When more than 1 byte is transferred (I2C_SLV3_LEN &gt; 1), data is read from (written to) sequential addresses starting from I2C_SLV3_REG.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>49</Address>
      <ShortName><![CDATA[I2C_SLV4_ADDR]]></ShortName>
      <Name><![CDATA[I2C Slave 4 Address]]></Name>
      <Description><![CDATA[Configures the device address and data transfer mode for Slave 4. I2C data transactions are performed at the Sample Rate, as defined in Register 25. The user is responsible for ensuring that I2C data transactions to and from each enabled Slave can be completed within a single period of the Sample Rate.

The I2C slave access rate can be reduced relative to the Sample Rate. This reduced access rate is determined by I2C_MST_DLY (Register 52). Whether a slave’s access rate is reduced relative to the Sample Rate is determined by I2C_MST_DELAY_CTRL (Register 103).

The processing order for the slaves is fixed. The sequence followed for processing the slaves is Slave 0, Slave 1, Slave 2, Slave 3 and Slave 4. If a particular Slave is disabled it will be skipped.

Each slave can either be accessed at the sample rate or at a reduced sample rate. In a case where some slaves are accessed at the Sample Rate and some slaves are accessed at the reduced rate, the sequence of accessing the slaves (Slave 0 to Slave 4) is still followed. However, the reduced rate slaves will be skipped if their access rate dictates that they should not be accessed during that particular cycle. For further information regarding the reduced access rate, please refer to Register 52. Whether a slave is accessed at the Sample Rate or at the reduced rate is determined by the Delay Enable bits in Register 103.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV4_RW]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[I2C slave data transactions between the MPU-60X0 and Slave 4 are set as either read or write operations by the I2C_SLV4_RW bit. When this bit is 1, the transfer is a read operation. When the bit is 0, the transfer is a write operation.

In read mode, the result of the read will be available in I2C_SLV4_DI. In write mode, the contents of I2C_SLV4_DO will be written into the slave device. A data transaction is performed only if the I2C_SLV4_EN bit is set to 1. The data transaction should be enabled once its parameters are configured in the _ADDR and _REG registers. For write, the _DO register is also required. I2C_SLV4_EN will be cleared after the transaction is performed once.

An interrupt is triggered at the completion of a Slave 4 data transaction if the interrupt is enabled. The status of this interrupt can be observed in Register 54.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>6</StartBit>
          <BitLength>7</BitLength>
          <ShortName><![CDATA[I2C_SLV4_ADDR]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Specifies the 7-bit I2C slave address of Slave 4.]]></Description>
          <RW>0</RW>
          <DataType>uns</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>50</Address>
      <ShortName><![CDATA[I2C_SLV4_REG]]></ShortName>
      <Name><![CDATA[I2C Slave 4 Register]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[I2C_SLV4_REG]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Specifies the internal register at which to begin data transfer within Slave 4.]]></Description>
          <RW>0</RW>
          <DataType>uns</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>51</Address>
      <ShortName><![CDATA[I2C_SLV4_DO]]></ShortName>
      <Name><![CDATA[I2C Slave 4 Data Output]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[I2C_SLV4_DO]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[This register stores the data to be written into the Slave 4. If I2C_SLV4_RW is set 1 (set to read), this register has no effect.]]></Description>
          <RW>0</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>52</Address>
      <ShortName><![CDATA[I2C_SLV4_CTRL]]></ShortName>
      <Name><![CDATA[I2C Slave 4 Control]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV4_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Enables Slave 4 for I2C data transaction. A data transaction is performed only if the I2C_SLV4_EN bit is set to 1. The data transaction should be enabled once its parameters are configured in the _ADDR and _REG registers. For write, the _DO register is also required. I2C_SLV4_EN will be cleared after the transaction is performed once.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>6</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV4_INT_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit enables the generation of an interrupt signal upon completion of a Slave 4 transaction. When cleared to 0, this bit disables the generation of an interrupt signal upon completion of a Slave 4 transaction.

The interrupt status can be observed in Register 54.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>5</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV4_REG_DIS]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Disable slave register address sending. When I2C_SLV4_REG_DIS is set to 1, the transaction will read or write data instead of writing a register address. This bit should equal 0 when specifying the register address within the Slave device to/from which the ensuing data transaction will take place.]]></Description>
          <RW>0</RW>
          <DataType>dis</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>4</StartBit>
          <BitLength>5</BitLength>
          <ShortName><![CDATA[I2C_MST_DLY]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[I2C_MST_DLY configures the reduced access rate of I2C slaves relative to the Sample Rate. When a slave’s access rate is decreased relative to the Sample Rate, the slave is accessed every:

1 / (1 + I2C_MST_DLY) samples

This base Sample Rate in turn is determined by SMPLRT_DIV (register 25) and DLPF_CFG (register 26). Whether a slave’s access rate is reduced relative to the Sample Rate is determined by I2C_MST_DELAY_CTRL (register 103).]]></Description>
          <RW>0</RW>
          <DataType>uns</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>53</Address>
      <ShortName><![CDATA[I2C_SLV4_DI]]></ShortName>
      <Name><![CDATA[I2C Slave 4 Data Input]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[I2C_SLV4_DI]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[This register stores the data read from Slave 4. This field is populated after a read transaction.]]></Description>
          <RW>0</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>54</Address>
      <ShortName><![CDATA[I2C_MST_STATUS]]></ShortName>
      <Name><![CDATA[I2C Master Status]]></Name>
      <Description><![CDATA[This register shows the status of the interrupt generating signals in the I2C Master within the MPU-60X0. This register also communicates the status of the FSYNC interrupt to the host processor.

Reading this register will clear all the status bits in the register.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[PASS_THROUGH]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[This bit reflects the status of the FSYNC interrupt from an external device into the MPU-60X0. This is used as a way to pass an external interrupt through the MPU-60X0 to the host application processor. When set to 1, this bit will cause an interrupt if FSYNC_INT_EN is asserted in INT_PIN_CFG (Register 55).]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>6</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV4_DONE]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Automatically sets to 1 when a Slave 4 transaction has completed. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted and if the SLV_4_DONE_INT bit is asserted in the I2C_SLV4_CTRL register (Register 52).]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>5</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_LOST_ARB]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[This bit automatically sets to 1 when the I2C Master has lost arbitration of the auxiliary I2C bus (an error condition). This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted.]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>4</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV4_NACK]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 4. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted.]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>3</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV3_NACK]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 3. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted.]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>2</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV2_NACK]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 2. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted.]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>1</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV1_NACK]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 1. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted.]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>0</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV0_NACK]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[This bit automatically sets to 1 when the I2C Master receives a NACK in a transaction with Slave 0. This triggers an interrupt if the I2C_MST_INT_EN bit in the INT_ENABLE register (Register 56) is asserted.]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>55</Address>
      <ShortName><![CDATA[INT_PIN_CFG]]></ShortName>
      <Name><![CDATA[INT Pin / Bypass Enable Configuration]]></Name>
      <Description><![CDATA[This register configures the behavior of the interrupt signals at the INT pins. This register is also used to enable the FSYNC Pin to be used as an interrupt to the host application processor, as well as to enable Bypass Mode on the I2C Master. This bit also enables the clock output.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[INT_LEVEL]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Configures interrupt pin logic level. When this bit is equal to 0, the logic level for the INT pin is active high. When this bit is equal to 1, the logic level for the INT pin is active low.]]></Description>
          <RW>0</RW>
          <DataType>set</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>6</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[INT_OPEN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Configures interrupt pin drive type. When this bit is equal to 0, the INT pin is configured as push-pull. When this bit is equal to 1, the INT pin is configured as open drain.]]></Description>
          <RW>0</RW>
          <DataType>set</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>5</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[LATCH_INT_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Configures interrupt latch mode. When this bit is equal to 0, the INT pin emits a 50us long pulse. When this bit is equal to 1, the INT pin is held high until the interrupt is cleared.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>4</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[INT_RD_CLEAR]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Configures interrupt read clear mode. When this bit is equal to 0, interrupt status bits are cleared only by reading INT_STATUS (Register 58). When this bit is equal to 1, interrupt status bits are cleared on any read operation.]]></Description>
          <RW>0</RW>
          <DataType>set</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>3</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[FSYNC_INT_LEVEL]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Configures FSYNC pin logic level. When this bit is equal to 0, the logic level for the FSYNC pin (when used as an interrupt to the host processor) is active high. When this bit is equal to 1, the logic level for the FSYNC pin (when used as an interrupt to the host processor) is active low.]]></Description>
          <RW>0</RW>
          <DataType>set</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>2</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[FSYNC_INT_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[FSYNC_INT_EN enables the FSYNC pin to be used as an interrupt to the host application processor. A transition to the active level specified in FSYNC_INT_LEVEL will trigger an interrupt. The status of this interrupt is read from the PASS_THROUGH bit in the I2C Master Status Register (Register 54).

When equal to 0, this bit disables the FSYNC pin from causing an interrupt to the host processor. When equal to 1, this bit enables the FSYNC pin to be used as an interrupt to the host processor.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>1</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_BYPASS_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When I2C_BYPASS_EN is equal to 1 and I2C_MST_EN (Register 106 bit[5]) is equal to 0, the host application processor will be able to directly access the auxiliary I2C bus of the MPU-60X0. When this bit is equal to 0, the host application processor will not be able to directly access the auxiliary I2C bus of the MPU-60X0 regardless of the state of I2C_MST_EN.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>0</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[CLKOUT_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When this bit is equal to 1, a reference clock output is provided at the CLKOUT pin. When this bit is equal to 0, the clock output is disabled.

For further information regarding CLKOUT, please refer to the MPU-60X0 Product Specification document.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>56</Address>
      <ShortName><![CDATA[INT_ENABLE]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[This register enables interrupt generation by interrupt sources.

For information regarding Free Fall detection, Motion detection, and Zero Motion detection, please refer to Registers 29 to 34. For information regarding the interrupt status for of each interrupt generation source, please refer to Register 58. Further information regarding I2C Master interrupt generation can be found in Register 54.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[FF_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit enables Free Fall detection to generate an interrupt.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>6</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[MOT_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit enables Motion detection to generate an interrupt.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>5</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[ZMOT_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit enables Zero Motion detection to generate an interrupt.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>4</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[FIFO_OFLOW_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit enables a FIFO buffer overflow to generate an interrupt.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>3</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_MST_INT_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit enables any of the I2C Master interrupt sources to generate an interrupt.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>2</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[PLL_RDY_INT_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>1</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[DMP_INT_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit enables DMP-related interrupts.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>0</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[RAW_RDY_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit enables the Data Ready interrupt, which occurs each time a write operation to all of the sensor registers has been completed.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>57</Address>
      <ShortName><![CDATA[DMP_INT_STATUS]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>5</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[DMP_INT_5]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>4</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[DMP_INT_4]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>3</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[DMP_INT_3]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>2</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[DMP_INT_2]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>1</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[DMP_INT_1]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>0</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[DMP_INT_0]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>58</Address>
      <ShortName><![CDATA[INT_STATUS]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[This register shows the interrupt status of each interrupt generation source. Each bit will clear after the register is read.
For information regarding the corresponding interrupt enable bits, please refer to Register 56. For a list of I2C Master interrupts, please refer to Register 54.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[FF_INT]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[This bit automatically sets to 1 when a Free Fall interrupt has been generated. The bit clears to 0 after the register has been read.]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>6</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[MOT_INT]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[This bit automatically sets to 1 when a Motion Detection interrupt has been generated. The bit clears to 0 after the register has been read.]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>5</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[ZMOT_INT]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[This bit automatically sets to 1 when a Zero Motion Detection interrupt has been generated. The bit clears to 0 after the register has been read.]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>4</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[FIFO_OFLOW_INT]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[This bit automatically sets to 1 when a FIFO buffer overflow interrupt has been generated. The bit clears to 0 after the register has been read.]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>3</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_MST_INT]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[This bit automatically sets to 1 when an I2C Master interrupt has been generated. For a list of I2C Master interrupts, please refer to Register 54. The bit clears to 0 after the register has been read.]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>2</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[PLL_RDY_INT]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>1</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[DMP_INT]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[This bit automatically sets to 1 when a DMP interrupt is generated. The bit clears to 0 after the register has been read. More specific DMP interrupt flags are contained in the DMP_INT_STATUS register (0x39).]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>0</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[RAW_RDY_INT]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[This bit automatically sets to 1 when a Data Ready interrupt is generated. The bit clears to 0 after the register has been read.]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>59</Address>
      <ShortName><![CDATA[ACCEL_XOUT_H]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store the most recent accelerometer measurements. Accelerometer measurements are written to these registers at the Sample Rate as defined in Register 25.

The accelerometer measurement registers, along with the temperature measurement registers, gyroscope measurement registers, and external sensor data registers, are composed of two sets of registers: an internal register set and a user-facing read register set.

The data within the accelerometer sensors’ internal register set is always updated at the Sample Rate. Meanwhile, the user-facing read register set duplicates the internal register set’s data values whenever the serial interface is idle. This guarantees that a burst read of sensor registers will read measurements from the same sampling instant. Note that if burst reads are not used, the user is responsible for ensuring a set of single byte reads correspond to a single sampling instant by checking the Data Ready interrupt.

Each 16-bit accelerometer measurement has a full scale defined in ACCEL_FS (Register 28). For each full scale setting, the accelerometers’ sensitivity per LSB in ACCEL_xOUT is shown in the table below.

AFS_SEL Full Scale Range LSB Sensitivity
0 ±2g 16384 LSB/mg
1 ±4g 8192 LSB/mg
2 ±8g 4096 LSB/mg
3 ±16g 2048 LSB/mg]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>15</StartBit>
          <BitLength>16</BitLength>
          <ShortName><![CDATA[ACCEL_XOUT]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[16-bit 2’s complement value. Stores the most recent X axis accelerometer measurement.]]></Description>
          <RW>1</RW>
          <DataType>sign</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>60</Address>
      <ShortName><![CDATA[ACCEL_XOUT_L]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store the most recent accelerometer measurements. Accelerometer measurements are written to these registers at the Sample Rate as defined in Register 25. See ACCEL_XOUT_H for more details.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
      </Fields>
    </Register>
    <Register>
      <Address>61</Address>
      <ShortName><![CDATA[ACCEL_YOUT_H]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store the most recent accelerometer measurements. Accelerometer measurements are written to these registers at the Sample Rate as defined in Register 25. See ACCEL_XOUT_H for more details.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>15</StartBit>
          <BitLength>16</BitLength>
          <ShortName><![CDATA[ACCEL_YOUT]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[16-bit 2’s complement value. Stores the most recent Y axis accelerometer measurement.]]></Description>
          <RW>1</RW>
          <DataType>sign</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>62</Address>
      <ShortName><![CDATA[ACCEL_YOUT_L]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store the most recent accelerometer measurements. Accelerometer measurements are written to these registers at the Sample Rate as defined in Register 25. See ACCEL_XOUT_H for more details.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
      </Fields>
    </Register>
    <Register>
      <Address>63</Address>
      <ShortName><![CDATA[ACCEL_ZOUT_H]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store the most recent accelerometer measurements. Accelerometer measurements are written to these registers at the Sample Rate as defined in Register 25. See ACCEL_XOUT_H for more details.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>15</StartBit>
          <BitLength>16</BitLength>
          <ShortName><![CDATA[ACCEL_ZOUT]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[16-bit 2’s complement value. Stores the most recent Z axis accelerometer measurement.]]></Description>
          <RW>1</RW>
          <DataType>sign</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>64</Address>
      <ShortName><![CDATA[ACCEL_ZOUT_L]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store the most recent accelerometer measurements. Accelerometer measurements are written to these registers at the Sample Rate as defined in Register 25. See ACCEL_XOUT_H for more details.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
      </Fields>
    </Register>
    <Register>
      <Address>65</Address>
      <ShortName><![CDATA[TEMP_OUT_H]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store the most recent temperature sensor measurement. Temperature measurements are written to these registers at the Sample Rate as defined in Register 25.

These temperature measurement registers, along with the accelerometer measurement registers, gyroscope measurement registers, and external sensor data registers, are composed of two sets of registers: an internal register set and a user-facing read register set.

The data within the temperature sensor’s internal register set is always updated at the Sample Rate. Meanwhile, the user-facing read register set duplicates the internal register set’s data values whenever the serial interface is idle. This guarantees that a burst read of sensor registers will read measurements from the same sampling instant. Note that if burst reads are not used, the user is responsible for ensuring a set of single byte reads correspond to a single sampling instant by checking the Data Ready interrupt.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>15</StartBit>
          <BitLength>16</BitLength>
          <ShortName><![CDATA[TEMP_OUT]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[16-bit signed value. Stores the most recent temperature sensor measurement.]]></Description>
          <RW>1</RW>
          <DataType>sign</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>66</Address>
      <ShortName><![CDATA[TEMP_OUT_L]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store the most recent temperature sensor measurement. Temperature measurements are written to these registers at the Sample Rate as defined in Register 25. See TEMP_OUT_H for more details.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
      </Fields>
    </Register>
    <Register>
      <Address>67</Address>
      <ShortName><![CDATA[GYRO_XOUT_H]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store the most recent gyroscope measurements. Gyroscope measurements are written to these registers at the Sample Rate as defined in Register 25.

These gyroscope measurement registers, along with the accelerometer measurement registers, temperature measurement registers, and external sensor data registers, are composed of two sets of registers: an internal register set and a user-facing read register set.

The data within the gyroscope sensors’ internal register set is always updated at the Sample Rate. Meanwhile, the user-facing read register set duplicates the internal register set’s data values whenever the serial interface is idle. This guarantees that a burst read of sensor registers will read measurements from the same sampling instant. Note that if burst reads are not used, the user is responsible for ensuring a set of single byte reads correspond to a single sampling instant by checking the Data Ready interrupt.

Each 16-bit gyroscope measurement has a full scale defined in FS_SEL (Register 27). For each full scale setting, the gyroscopes’ sensitivity per LSB in GYRO_xOUT is shown in the table below:

FS_SEL Full Scale Range LSB Sensitivity
0 ± 250 °/s 131 LSB/°/s
1 ± 500 °/s 65.5 LSB/°/s
2 ± 1000 °/s 32.8 LSB/°/s
3 ± 2000 °/s 16.4 LSB/°/s]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>15</StartBit>
          <BitLength>16</BitLength>
          <ShortName><![CDATA[GYRO_XOUT]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[16-bit 2’s complement value. Stores the most recent X axis gyroscope measurement.]]></Description>
          <RW>1</RW>
          <DataType>sign</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>68</Address>
      <ShortName><![CDATA[GYRO_XOUT_L]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store the most recent gyroscope measurements. Gyroscope measurements are written to these registers at the Sample Rate as defined in Register 25. See GYRO_XOUT_H for more details.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
      </Fields>
    </Register>
    <Register>
      <Address>69</Address>
      <ShortName><![CDATA[GYRO_YOUT_H]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store the most recent gyroscope measurements. Gyroscope measurements are written to these registers at the Sample Rate as defined in Register 25. See GYRO_XOUT_H for more details.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>15</StartBit>
          <BitLength>16</BitLength>
          <ShortName><![CDATA[GYRO_YOUT]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[16-bit 2’s complement value. Stores the most recent Y axis gyroscope measurement.]]></Description>
          <RW>1</RW>
          <DataType>sign</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>70</Address>
      <ShortName><![CDATA[GYRO_YOUT_L]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store the most recent gyroscope measurements. Gyroscope measurements are written to these registers at the Sample Rate as defined in Register 25. See GYRO_XOUT_H for more details.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
      </Fields>
    </Register>
    <Register>
      <Address>71</Address>
      <ShortName><![CDATA[GYRO_ZOUT_H]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store the most recent gyroscope measurements. Gyroscope measurements are written to these registers at the Sample Rate as defined in Register 25. See GYRO_XOUT_H for more details.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>15</StartBit>
          <BitLength>16</BitLength>
          <ShortName><![CDATA[GYRO_ZOUT]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[16-bit 2’s complement value. Stores the most recent Z axis gyroscope measurement.]]></Description>
          <RW>1</RW>
          <DataType>sign</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>72</Address>
      <ShortName><![CDATA[GYRO_ZOUT_L]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store the most recent gyroscope measurements. Gyroscope measurements are written to these registers at the Sample Rate as defined in Register 25. See GYRO_XOUT_H for more details.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
      </Fields>
    </Register>
    <Register>
      <Address>73</Address>
      <ShortName><![CDATA[EXT_SENS_DATA_00]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53).

External sensor data is written to these registers at the Sample Rate as defined in Register 25. This access rate can be reduced by using the Slave Delay Enable registers (Register 103).

External sensor data registers, along with the gyroscope measurement registers, accelerometer measurement registers, and temperature measurement registers, are composed of two sets of registers: an internal register set and a user-facing read register set.

The data within the external sensors’ internal register set is always updated at the Sample Rate (or the reduced access rate) whenever the serial interface is idle. This guarantees that a burst read of sensor registers will read measurements from the same sampling instant. Note that if burst reads are not used, the user is responsible for ensuring a set of single byte reads correspond to a single sampling instant by checking the Data Ready interrupt.

Data is placed in these external sensor data registers according to I2C_SLV0_CTRL, I2C_SLV1_CTRL, I2C_SLV2_CTRL, and I2C_SLV3_CTRL (Registers 39, 42, 45, and 48). When more than zero bytes are read (I2C_SLVx_LEN &gt; 0) from an enabled slave (I2C_SLVx_EN = 1), the slave is read at the Sample Rate (as defined in Register 25) or delayed rate (if specified in Register 52 and 103). During each Sample cycle, slave reads are performed in order of Slave number. If all slaves are enabled with more than zero bytes to be read, the order will be Slave 0, followed by Slave 1, Slave 2, and Slave 3.

Each enabled slave will have EXT_SENS_DATA registers associated with it by number of bytes read (I2C_SLVx_LEN) in order of slave number, starting from EXT_SENS_DATA_00. Note that this means enabling or disabling a slave may change the higher numbered slaves’ associated registers. Furthermore, if fewer total bytes are being read from the external sensors as a result of such a change, then the data remaining in the registers which no longer have an associated slave device (i.e. high numbered registers) will remain in these previously allocated registers unless reset.

If the sum of the read lengths of all SLVx transactions exceed the number of available EXT_SENS_DATA registers, the excess bytes will be dropped. There are 24 EXT_SENS_DATA registers and hence the total read lengths between all the slaves cannot be greater than 24 or some bytes will be lost.

Note: Slave 4’s behavior is distinct from that of Slaves 0-3. For further information regarding the characteristics of Slave 4, please refer to Registers 49 to 53.

Example:

Suppose that Slave 0 is enabled with 4 bytes to be read (I2C_SLV0_EN = 1 and I2C_SLV0_LEN = 4) while Slave 1 is enabled with 2 bytes to be read, (I2C_SLV1_EN=1 and I2C_SLV1_LEN = 2). In such a situation, EXT_SENS_DATA _00 through _03 will be associated with Slave 0, while EXT_SENS_DATA _04 and 05 will be associated with Slave 1.
If Slave 2 is enabled as well, registers starting from EXT_SENS_DATA_06 will be allocated to Slave 2.
If Slave 2 is disabled while Slave 3 is enabled in this same situation, then registers starting from EXT_SENS_DATA_06 will be allocated to Slave 3 instead.

Register Allocation for Dynamic Disable vs. Normal Disable

If a slave is disabled at any time, the space initially allocated to the slave in the EXT_SENS_DATA register, will remain associated with that slave. This is to avoid dynamic adjustment of the register allocation.

The allocation of the EXT_SENS_DATA registers is recomputed only when (1) all slaves are disabled, or (2) the I2C_MST_RST bit is set (Register 106) .

This above is also true if one of the slaves gets NACKed and stops functioning.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[EXT_SENS_DATA_00]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>74</Address>
      <ShortName><![CDATA[EXT_SENS_DATA_01]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53). For more information, see EXT_SENS_DATA_00.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[EXT_SENS_DATA_01]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>75</Address>
      <ShortName><![CDATA[EXT_SENS_DATA_02]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53). For more information, see EXT_SENS_DATA_00.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[EXT_SENS_DATA_02]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>76</Address>
      <ShortName><![CDATA[EXT_SENS_DATA_03]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53). For more information, see EXT_SENS_DATA_00.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[EXT_SENS_DATA_03]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>77</Address>
      <ShortName><![CDATA[EXT_SENS_DATA_04]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53). For more information, see EXT_SENS_DATA_00.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[EXT_SENS_DATA_04]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>78</Address>
      <ShortName><![CDATA[EXT_SENS_DATA_05]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53). For more information, see EXT_SENS_DATA_00.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[EXT_SENS_DATA_05]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>79</Address>
      <ShortName><![CDATA[EXT_SENS_DATA_06]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53). For more information, see EXT_SENS_DATA_00.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[EXT_SENS_DATA_06]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>80</Address>
      <ShortName><![CDATA[EXT_SENS_DATA_07]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53). For more information, see EXT_SENS_DATA_00.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[EXT_SENS_DATA_07]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>81</Address>
      <ShortName><![CDATA[EXT_SENS_DATA_08]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53). For more information, see EXT_SENS_DATA_00.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[EXT_SENS_DATA_08]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>82</Address>
      <ShortName><![CDATA[EXT_SENS_DATA_09]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53). For more information, see EXT_SENS_DATA_00.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[EXT_SENS_DATA_09]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>83</Address>
      <ShortName><![CDATA[EXT_SENS_DATA_10]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53). For more information, see EXT_SENS_DATA_00.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[EXT_SENS_DATA_10]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>84</Address>
      <ShortName><![CDATA[EXT_SENS_DATA_11]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53). For more information, see EXT_SENS_DATA_00.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[EXT_SENS_DATA_11]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>85</Address>
      <ShortName><![CDATA[EXT_SENS_DATA_12]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53). For more information, see EXT_SENS_DATA_00.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[EXT_SENS_DATA_12]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>86</Address>
      <ShortName><![CDATA[EXT_SENS_DATA_13]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53). For more information, see EXT_SENS_DATA_00.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[EXT_SENS_DATA_13]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>87</Address>
      <ShortName><![CDATA[EXT_SENS_DATA_14]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53). For more information, see EXT_SENS_DATA_00.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[EXT_SENS_DATA_14]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>88</Address>
      <ShortName><![CDATA[EXT_SENS_DATA_15]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53). For more information, see EXT_SENS_DATA_00.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[EXT_SENS_DATA_15]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>89</Address>
      <ShortName><![CDATA[EXT_SENS_DATA_16]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53). For more information, see EXT_SENS_DATA_00.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[EXT_SENS_DATA_16]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>90</Address>
      <ShortName><![CDATA[EXT_SENS_DATA_17]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53). For more information, see EXT_SENS_DATA_00.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[EXT_SENS_DATA_17]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>91</Address>
      <ShortName><![CDATA[EXT_SENS_DATA_18]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53). For more information, see EXT_SENS_DATA_00.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[EXT_SENS_DATA_18]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>92</Address>
      <ShortName><![CDATA[EXT_SENS_DATA_19]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53). For more information, see EXT_SENS_DATA_00.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[EXT_SENS_DATA_19]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>93</Address>
      <ShortName><![CDATA[EXT_SENS_DATA_20]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53). For more information, see EXT_SENS_DATA_00.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[EXT_SENS_DATA_20]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>94</Address>
      <ShortName><![CDATA[EXT_SENS_DATA_21]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53). For more information, see EXT_SENS_DATA_00.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[EXT_SENS_DATA_21]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>95</Address>
      <ShortName><![CDATA[EXT_SENS_DATA_22]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53). For more information, see EXT_SENS_DATA_00.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[EXT_SENS_DATA_22]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>96</Address>
      <ShortName><![CDATA[EXT_SENS_DATA_23]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[These registers store data read from external sensors by the Slave 0, 1, 2, and 3 on the auxiliary I2C interface. Data read by Slave 4 is stored in I2C_SLV4_DI (Register 53). For more information, see EXT_SENS_DATA_00.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[EXT_SENS_DATA_23]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>1</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>97</Address>
      <ShortName><![CDATA[MOT_DETECT_STATUS]]></ShortName>
      <Name><![CDATA[Motion Detection Status]]></Name>
      <Description><![CDATA[This register reports the status of Motion detection and Zero Motion detection. The Motion detection bits, MOT_XNEG, MOT_XPOS, MOT_YNEG, MOT_YPOS, MOT_ZNEG, and MOT_ZPOS, report the axis and polarity of motion which generated a Motion Detection interrupt.

The MOT_ZRMOT bit is set to 1 when Zero Motion has been detected. Reading this register clears the Motion detection bits. However, the MOT_ZRMOT bit does not clear until Zero Motion is no longer detected.

For more information regarding Motion detection and Zero Motion detection, please refer to Registers 31 to 34 in this document, as well as Sections 8.3 and 8.4 of the MPU-6000/MPU-6050 Product Specification document.]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[MOT_XNEG]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[This bit automatically sets to 1 when motion in the negative X axis has generated a Motion detection interrupt.]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>6</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[MOT_XPOS]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[This bit automatically sets to 1 when motion in the positive X axis has generated a Motion detection interrupt.]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>5</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[MOT_YNEG]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[This bit automatically sets to 1 when motion in the negative Y axis has generated a Motion detection interrupt.]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>4</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[MOT_YPOS]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[This bit automatically sets to 1 when motion in the positive Y axis has generated a Motion detection interrupt.]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>3</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[MOT_ZNEG]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[This bit automatically sets to 1 when motion in the negative Z axis has generated a Motion detection interrupt.]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>2</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[MOT_ZPOS]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[This bit automatically sets to 1 when motion in the positive Z axis has generated a Motion detection interrupt.]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>0</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[MOT_ZRMOT]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[This bit automatically sets to 1 when Zero Motion detection interrupt is generated.]]></Description>
          <RW>1</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>99</Address>
      <ShortName><![CDATA[I2C_SLV0_DO]]></ShortName>
      <Name><![CDATA[I2C Slave 0 Data Out]]></Name>
      <Description><![CDATA[This register holds the output data written into Slave 0 when Slave 0 is set to write mode. For further information regarding Slave 0 control, please refer to Registers 37 to 39.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[I2C_SLV0_DO]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[8 bit unsigned value that is written into Slave 0 when Slave 0 is set to write mode.]]></Description>
          <RW>0</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>100</Address>
      <ShortName><![CDATA[I2C_SLV1_DO]]></ShortName>
      <Name><![CDATA[I2C Slave 1 Data Out]]></Name>
      <Description><![CDATA[This register holds the output data written into Slave 1 when Slave 1 is set to write mode. For further information regarding Slave 1 control, please refer to Registers 40 to 42.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[I2C_SLV1_DO]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[8 bit unsigned value that is written into Slave 1 when Slave 1 is set to write mode.]]></Description>
          <RW>0</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>101</Address>
      <ShortName><![CDATA[I2C_SLV2_DO]]></ShortName>
      <Name><![CDATA[I2C Slave 2 Data Out]]></Name>
      <Description><![CDATA[This register holds the output data written into Slave 2 when Slave 2 is set to write mode. For further information regarding Slave 2 control, please refer to Registers 43 to 45.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[I2C_SLV2_DO]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[8 bit unsigned value that is written into Slave 2 when Slave 2 is set to write mode.]]></Description>
          <RW>0</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>102</Address>
      <ShortName><![CDATA[I2C_SLV3_DO]]></ShortName>
      <Name><![CDATA[I2C Slave 3 Data Out]]></Name>
      <Description><![CDATA[This register holds the output data written into Slave 3 when Slave 3 is set to write mode. For further information regarding Slave 3 control, please refer to Registers 46 to 48.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[I2C_SLV3_DO]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[8 bit unsigned value that is written into Slave 3 when Slave 3 is set to write mode.]]></Description>
          <RW>0</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>103</Address>
      <ShortName><![CDATA[I2C_MST_DELAY_CTRL]]></ShortName>
      <Name><![CDATA[I2C Master Delay Control]]></Name>
      <Description><![CDATA[This register is used to specify the timing of external sensor data shadowing. The register is also used to decrease the access rate of slave devices relative to the Sample Rate.

When DELAY_ES_SHADOW is set to 1, shadowing of external sensor data is delayed until all data has been received. When I2C_SLV4_DLY_EN, I2C_SLV3_DLY_EN, I2C_SLV2_DLY_EN, I2C_SLV1_DLY_EN, and I2C_SLV0_DLY_EN are enabled, the rate of access for the corresponding slave devices is reduced.

When a slave’s access rate is decreased relative to the Sample Rate, the slave is accessed every:

1 / (1 + I2C_MST_DLY)

samples. This base Sample Rate in turn is determined by SMPLRT_DIV (register 25) and DLPF_CFG (register 26).

For further information regarding I2C_MST_DLY, please refer to register 52. For further information regarding the Sample Rate, please refer to register 25. Bits 6 and 5 are reserved.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[DELAY_ES_SHADOW]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set, delays shadowing of external sensor data until all data has been received.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>4</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV4_DLY_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When enabled, slave 4 will only be accessed at a decreased rate.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>3</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV3_DLY_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When enabled, slave 3 will only be accessed at a decreased rate.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>2</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV2_DLY_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When enabled, slave 2 will only be accessed at a decreased rate.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>1</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV1_DLY_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When enabled, slave 1 will only be accessed at a decreased rate.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>0</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_SLV0_DLY_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When enabled, slave 0 will only be accessed at a decreased rate.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>104</Address>
      <ShortName><![CDATA[SIGNAL_PATH_RESET]]></ShortName>
      <Name><![CDATA[Signal Path Reset]]></Name>
      <Description><![CDATA[This register is used to reset the analog and digital signal paths of the gyroscope, accelerometer, and temperature sensors. The reset will revert the signal path analog to digital converters and filters to their power up configurations.

Note: This register does not clear the sensor registers.

Bits 7 to 3 are reserved.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>2</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[GYRO_RESET]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit resets the gyroscope analog and digital signal paths.]]></Description>
          <RW>0</RW>
          <DataType>trig</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>1</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[ACCEL_RESET]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit resets the accelerometer analog and digital signal paths.]]></Description>
          <RW>0</RW>
          <DataType>trig</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>0</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[TEMP_RESET]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit resets the temperature sensor analog and digital signal paths.]]></Description>
          <RW>0</RW>
          <DataType>trig</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>105</Address>
      <ShortName><![CDATA[MOT_DETECT_CTRL]]></ShortName>
      <Name><![CDATA[Motion Detection Control]]></Name>
      <Description><![CDATA[This register is used to add delay to the accelerometer power on time. It is also used to configure the Free Fall and Motion detection decrement rate.

The accelerometer data path provides samples to the sensor registers, Motion detection, Zero Motion detection, and Free Fall detection modules. The signal path contains filters which must be flushed on wake-up with new samples before the detection modules begin operations. The default wake-up delay, of 4ms can be lengthened by up to 3ms. This additional delay is specified in ACCEL_ON_DELAY in units of 1 LSB = 1 ms. The user may select any value above zero unless instructed otherwise by InvenSense. Please refer to Section 8 of the MPU-6000/MPU-6050 Product Specification document for further information regarding the detection modules.

Detection is registered by the Free Fall detection module or the Motion detection module after accelerometer measurements meet their respective threshold conditions over a specified number of samples. When the threshold conditions are met, the corresponding detection counter increments by 1. The user may control the rate at which the detection counter decrements when the threshold condition is not met by configuring FF_COUNT and MOT_COUNT. The decrement rate can be set according to the following table:

FF_COUNT or MOT_COUNT Counter Decrement
0 Reset
1 1
2 2
3 4

When FF_COUNT or MOT_COUNT are configured to 0 (reset), any non-qualifying sample will reset the corresponding counter to 0. For further information on Free Fall detection and Motion detection, please refer to Registers 29 to 32.

Bits 7 and 6 are reserved.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>5</StartBit>
          <BitLength>2</BitLength>
          <ShortName><![CDATA[ACCEL_ON_DELAY]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[2-bit unsigned value. Specifies the additional power-on delay applied to accelerometer data path modules. Unit of 1 LSB = 1 ms.]]></Description>
          <RW>0</RW>
          <DataType>uns</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>3</StartBit>
          <BitLength>2</BitLength>
          <ShortName><![CDATA[FF_COUNT]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[2-bit unsigned value. Configures the Free Fall detection counter decrement rate.]]></Description>
          <RW>0</RW>
          <DataType>set</DataType>
          <Options>
            <Option>
              <Value>0</Value>
              <Format>2</Format>
              <Name><![CDATA[Reset]]></Name>
              <Description><![CDATA[2-bit unsigned value. Configures the Free Fall detection counter decrement rate.]]></Description>
            </Option>
            <Option>
              <Value>1</Value>
              <Format>2</Format>
              <Name><![CDATA[1]]></Name>
              <Description><![CDATA[2-bit unsigned value. Configures the Free Fall detection counter decrement rate.]]></Description>
            </Option>
            <Option>
              <Value>2</Value>
              <Format>2</Format>
              <Name><![CDATA[2]]></Name>
              <Description><![CDATA[2-bit unsigned value. Configures the Free Fall detection counter decrement rate.]]></Description>
            </Option>
            <Option>
              <Value>3</Value>
              <Format>2</Format>
              <Name><![CDATA[4]]></Name>
              <Description><![CDATA[2-bit unsigned value. Configures the Free Fall detection counter decrement rate.]]></Description>
            </Option>
          </Options>
        </Field>
        <Field>
          <StartBit>1</StartBit>
          <BitLength>2</BitLength>
          <ShortName><![CDATA[MOT_COUNT]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[2-bit unsigned value. Configures the Motion detection counter decrement rate.]]></Description>
          <RW>0</RW>
          <DataType>set</DataType>
          <Options>
            <Option>
              <Value>0</Value>
              <Format>2</Format>
              <Name><![CDATA[Reset]]></Name>
              <Description><![CDATA[2-bit unsigned value. Configures the Motion detection counter decrement rate.]]></Description>
            </Option>
            <Option>
              <Value>1</Value>
              <Format>2</Format>
              <Name><![CDATA[1]]></Name>
              <Description><![CDATA[2-bit unsigned value. Configures the Motion detection counter decrement rate.]]></Description>
            </Option>
            <Option>
              <Value>2</Value>
              <Format>2</Format>
              <Name><![CDATA[2]]></Name>
              <Description><![CDATA[2-bit unsigned value. Configures the Motion detection counter decrement rate.]]></Description>
            </Option>
            <Option>
              <Value>3</Value>
              <Format>2</Format>
              <Name><![CDATA[4]]></Name>
              <Description><![CDATA[2-bit unsigned value. Configures the Motion detection counter decrement rate.]]></Description>
            </Option>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>106</Address>
      <ShortName><![CDATA[USER_CTRL]]></ShortName>
      <Name><![CDATA[User Control]]></Name>
      <Description><![CDATA[This register allows the user to enable and disable the FIFO buffer, I2C Master Mode, and primary I2C interface. The FIFO buffer, I2C Master, sensor signal paths and sensor registers can also be reset using this register.

When I2C_MST_EN is set to 1, I2C Master Mode is enabled. In this mode, the MPU-60X0 acts as the I2C Master to the external sensor slave devices on the auxiliary I2C bus. When this bit is cleared to 0, the auxiliary I2C bus lines (AUX_DA and AUX_CL) are logically driven by the primary I2C bus (SDA and SCL). This is a precondition to enabling Bypass Mode. For further information regarding Bypass Mode, please refer to Register 55.

MPU-6000: The primary SPI interface will be enabled in place of the disabled primary I2C interface when I2C_IF_DIS is set to 1.
MPU-6050: Always write 0 to I2C_IF_DIS.

When the reset bits (DMP_RESET, FIFO_RESET, I2C_MST_RESET, and SIG_COND_RESET) are set to 1, these reset bits will trigger a reset and then clear to 0.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[DMP_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit enables Digital Motion Processor (DMP) operations.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>6</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[FIFO_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit enables FIFO operations. When this bit is cleared to 0, the FIFO buffer is disabled. The FIFO buffer cannot be written to or read from while disabled. The FIFO buffer’s state does not change unless the MPU-60X0 is power cycled.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>5</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_MST_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit enables I2C Master Mode. When this bit is cleared to 0, the auxiliary I2C bus lines (AUX_DA and AUX_CL) are logically driven by the primary I2C bus (SDA and SCL).]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>4</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_IF_DIS]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[MPU-6000: When set to 1, this bit disables the primary I2C interface and enables the SPI interface instead.
MPU-6050: Always write this bit as zero.]]></Description>
          <RW>0</RW>
          <DataType>dis</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>3</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[DMP_RESET]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[This bit resets the DMP engine when set to 1 while DMP_EN equals 0. This bit automatically clears to 0 after the reset has been triggered.]]></Description>
          <RW>0</RW>
          <DataType>trig</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>2</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[FIFO_RESET]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[This bit resets the FIFO buffer when set to 1 while FIFO_EN equals 0. This bit automatically clears to 0 after the reset has been triggered.]]></Description>
          <RW>0</RW>
          <DataType>trig</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>1</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[I2C_MST_RESET]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[This bit resets the I2C Master when set to 1 while I2C_MST_EN equals 0. This bit automatically clears to 0 after the reset has been triggered.]]></Description>
          <RW>0</RW>
          <DataType>trig</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>0</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[SIG_COND_RESET]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit resets the signal paths for all sensors (gyroscopes, accelerometers, and temperature sensor). This operation will also clear the sensor registers. This bit automatically clears to 0 after the reset has been triggered.

When resetting only the signal path (and not the sensor registers), please use Register 104, SIGNAL_PATH_RESET.]]></Description>
          <RW>0</RW>
          <DataType>trig</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>107</Address>
      <ShortName><![CDATA[PWR_MGMT_1]]></ShortName>
      <Name><![CDATA[Power Management 1]]></Name>
      <Description><![CDATA[This register allows the user to configure the power mode and clock source. It also provides a bit for resetting the entire device, and a bit for disabling the temperature sensor.

By setting SLEEP to 1, the MPU-60X0 can be put into low power sleep mode. When CYCLE is set to 1 while SLEEP is disabled, the MPU-60X0 will be put into Cycle Mode. In Cycle Mode, the device cycles between sleep mode and waking up to take a single sample of data from active sensors at a rate determined by LP_WAKE_CTRL (register 108). To configure the wake frequency, use LP_WAKE_CTRL within the Power Management 2 register (Register 108).

An internal 8MHz oscillator, gyroscope based clock, or external sources can be selected as the MPU-60X0 clock source. When the internal 8 MHz oscillator or an external source is chosen as the clock source, the MPU-60X0 can operate in low power modes with the gyroscopes disabled.

Upon power up, the MPU-60X0 clock source defaults to the internal oscillator. However, it is highly recommended that the device be configured to use one of the gyroscopes (or an external clock source) as the clock reference for improved stability. The clock source can be selected according to the following table:

CLKSEL Clock Source
0 Internal 8MHz oscillator
1 PLL with X axis gyroscope reference
2 PLL with Y axis gyroscope reference
3 PLL with Z axis gyroscope reference
4 PLL with external 32.768kHz reference
5 PLL with external 19.2MHz reference
6 Reserved
7 Stops the clock and keeps the timing generator in reset

For further information regarding the MPU-60X0 clock source, please refer to the MPU-6000/MPU-6050 Product Specification document.

Bit 4 is reserved.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[DEVICE_RESET]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit resets all internal registers to their default values. The bit automatically clears to 0 once the reset is done.

The default values for each register can be found in Section 3.]]></Description>
          <RW>0</RW>
          <DataType>trig</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>6</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[SLEEP]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit puts the MPU-60X0 into sleep mode. Note: default power-on state for MPU-60X0 is in sleep mode.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>5</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[CYCLE]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When this bit is set to 1 and SLEEP is disabled, the MPU-60X0 will cycle between sleep mode and waking up to take a single sample of data from active sensors at a rate determined by LP_WAKE_CTRL (register 108).]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>3</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[TEMP_DIS]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit disables the temperature sensor.]]></Description>
          <RW>0</RW>
          <DataType>dis</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>2</StartBit>
          <BitLength>3</BitLength>
          <ShortName><![CDATA[CLK_SEL]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[3-bit unsigned value. Specifies the clock source of the device.


The clock source can be selected according to the following table:

CLKSEL Clock Source
0 Internal 8MHz oscillator
1 PLL with X axis gyroscope reference
2 PLL with Y axis gyroscope reference
3 PLL with Z axis gyroscope reference
4 PLL with external 32.768kHz reference
5 PLL with external 19.2MHz reference
6 Reserved
7 Stops the clock and keeps the timing generator in reset]]></Description>
          <RW>0</RW>
          <DataType>set</DataType>
          <Options>
            <Option>
              <Value>0</Value>
              <Format>3</Format>
              <Name><![CDATA[Internal 8MHz oscillator]]></Name>
              <Description><![CDATA[3-bit unsigned value. Specifies the clock source of the device.


The clock source can be selected according to the following table:

CLKSEL Clock Source
0 Internal 8MHz oscillator
1 PLL with X axis gyroscope reference
2 PLL with Y axis gyroscope reference
3 PLL with Z axis gyroscope reference
4 PLL with external 32.768kHz reference
5 PLL with external 19.2MHz reference
6 Reserved
7 Stops the clock and keeps the timing generator in reset]]></Description>
            </Option>
            <Option>
              <Value>1</Value>
              <Format>3</Format>
              <Name><![CDATA[PLL with X axis gyroscope reference]]></Name>
              <Description><![CDATA[3-bit unsigned value. Specifies the clock source of the device.


The clock source can be selected according to the following table:

CLKSEL Clock Source
0 Internal 8MHz oscillator
1 PLL with X axis gyroscope reference
2 PLL with Y axis gyroscope reference
3 PLL with Z axis gyroscope reference
4 PLL with external 32.768kHz reference
5 PLL with external 19.2MHz reference
6 Reserved
7 Stops the clock and keeps the timing generator in reset]]></Description>
            </Option>
            <Option>
              <Value>2</Value>
              <Format>3</Format>
              <Name><![CDATA[PLL with Y axis gyroscope reference]]></Name>
              <Description><![CDATA[3-bit unsigned value. Specifies the clock source of the device.


The clock source can be selected according to the following table:

CLKSEL Clock Source
0 Internal 8MHz oscillator
1 PLL with X axis gyroscope reference
2 PLL with Y axis gyroscope reference
3 PLL with Z axis gyroscope reference
4 PLL with external 32.768kHz reference
5 PLL with external 19.2MHz reference
6 Reserved
7 Stops the clock and keeps the timing generator in reset]]></Description>
            </Option>
            <Option>
              <Value>3</Value>
              <Format>3</Format>
              <Name><![CDATA[PLL with Z axis gyroscope reference]]></Name>
              <Description><![CDATA[3-bit unsigned value. Specifies the clock source of the device.


The clock source can be selected according to the following table:

CLKSEL Clock Source
0 Internal 8MHz oscillator
1 PLL with X axis gyroscope reference
2 PLL with Y axis gyroscope reference
3 PLL with Z axis gyroscope reference
4 PLL with external 32.768kHz reference
5 PLL with external 19.2MHz reference
6 Reserved
7 Stops the clock and keeps the timing generator in reset]]></Description>
            </Option>
            <Option>
              <Value>4</Value>
              <Format>3</Format>
              <Name><![CDATA[PLL with external 32.768kHz reference]]></Name>
              <Description><![CDATA[3-bit unsigned value. Specifies the clock source of the device.


The clock source can be selected according to the following table:

CLKSEL Clock Source
0 Internal 8MHz oscillator
1 PLL with X axis gyroscope reference
2 PLL with Y axis gyroscope reference
3 PLL with Z axis gyroscope reference
4 PLL with external 32.768kHz reference
5 PLL with external 19.2MHz reference
6 Reserved
7 Stops the clock and keeps the timing generator in reset]]></Description>
            </Option>
            <Option>
              <Value>5</Value>
              <Format>3</Format>
              <Name><![CDATA[PLL with external 19.2MHz reference]]></Name>
              <Description><![CDATA[3-bit unsigned value. Specifies the clock source of the device.


The clock source can be selected according to the following table:

CLKSEL Clock Source
0 Internal 8MHz oscillator
1 PLL with X axis gyroscope reference
2 PLL with Y axis gyroscope reference
3 PLL with Z axis gyroscope reference
4 PLL with external 32.768kHz reference
5 PLL with external 19.2MHz reference
6 Reserved
7 Stops the clock and keeps the timing generator in reset]]></Description>
            </Option>
            <Option>
              <Value>6</Value>
              <Format>3</Format>
              <Name><![CDATA[RESERVED]]></Name>
              <Description><![CDATA[3-bit unsigned value. Specifies the clock source of the device.


The clock source can be selected according to the following table:

CLKSEL Clock Source
0 Internal 8MHz oscillator
1 PLL with X axis gyroscope reference
2 PLL with Y axis gyroscope reference
3 PLL with Z axis gyroscope reference
4 PLL with external 32.768kHz reference
5 PLL with external 19.2MHz reference
6 Reserved
7 Stops the clock and keeps the timing generator in reset]]></Description>
            </Option>
            <Option>
              <Value>7</Value>
              <Format>3</Format>
              <Name><![CDATA[Clock stopped, timing generator in reset]]></Name>
              <Description><![CDATA[3-bit unsigned value. Specifies the clock source of the device.


The clock source can be selected according to the following table:

CLKSEL Clock Source
0 Internal 8MHz oscillator
1 PLL with X axis gyroscope reference
2 PLL with Y axis gyroscope reference
3 PLL with Z axis gyroscope reference
4 PLL with external 32.768kHz reference
5 PLL with external 19.2MHz reference
6 Reserved
7 Stops the clock and keeps the timing generator in reset]]></Description>
            </Option>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>108</Address>
      <ShortName><![CDATA[PWR_MGMT_2]]></ShortName>
      <Name><![CDATA[Power Management 2]]></Name>
      <Description><![CDATA[This register allows the user to configure the frequency of wake-ups in Accelerometer Only Low Power Mode. This register also allows the user to put individual axes of the accelerometer and gyroscope into standby mode.

The MPU-60X0 can be put into Accerlerometer Only Low Power Mode by setting PWRSEL to 1 in the Power Management 1 register (Register 107). In this mode, the device will power off all devices except for the primary I2C interface, waking only the accelerometer at fixed intervals to take a single measurement. The frequency of wake-ups can be configured with LP_WAKE_CTRL as shown below:

LP_WAKE_CTRL Wake-up Frequency
0 1.25 Hz
1 2.5 Hz
2 5 Hz
3 10 Hz

For further information regarding the MPU-9150’s power modes, please refer to Register 107.

The user can put individual accelerometer and gyroscopes axes into standby mode by using this register. If the device is using a gyroscope axis as the clock source and this axis is put into standby mode, the clock source will automatically be changed to the internal 8MHz oscillator.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[LP_WAKE_CTRL]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[2-bit unsigned value. Specifies the frequency of wake-ups during Accelerometer Only Low Power Mode.]]></Description>
          <RW>0</RW>
          <DataType>set</DataType>
          <Options>
            <Option>
              <Value>0</Value>
              <Format>1</Format>
              <Name><![CDATA[1.25 Hz]]></Name>
              <Description><![CDATA[2-bit unsigned value. Specifies the frequency of wake-ups during Accelerometer Only Low Power Mode.]]></Description>
            </Option>
            <Option>
              <Value>1</Value>
              <Format>1</Format>
              <Name><![CDATA[2.5 Hz]]></Name>
              <Description><![CDATA[2-bit unsigned value. Specifies the frequency of wake-ups during Accelerometer Only Low Power Mode.]]></Description>
            </Option>
            <Option>
              <Value>2</Value>
              <Format>1</Format>
              <Name><![CDATA[5 Hz]]></Name>
              <Description><![CDATA[2-bit unsigned value. Specifies the frequency of wake-ups during Accelerometer Only Low Power Mode.]]></Description>
            </Option>
            <Option>
              <Value>3</Value>
              <Format>1</Format>
              <Name><![CDATA[10 Hz]]></Name>
              <Description><![CDATA[2-bit unsigned value. Specifies the frequency of wake-ups during Accelerometer Only Low Power Mode.]]></Description>
            </Option>
          </Options>
        </Field>
        <Field>
          <StartBit>5</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[STBY_XA]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit puts the X axis accelerometer into standby mode.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>4</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[STBY_YA]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit puts the Y axis accelerometer into standby mode.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>3</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[STBY_ZA]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit puts the Z axis accelerometer into standby mode.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>2</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[STBY_XG]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit puts the X axis gyroscope into standby mode.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>1</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[STBY_YG]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit puts the Y axis gyroscope into standby mode.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>0</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[STBY_ZG]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[When set to 1, this bit puts the Z axis gyroscope into standby mode.]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>109</Address>
      <ShortName><![CDATA[BANK_SEL]]></ShortName>
      <Name><![CDATA[Memory Bank Selection]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>6</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[PRFTCH_EN]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>5</StartBit>
          <BitLength>1</BitLength>
          <ShortName><![CDATA[CFG_USER_BANK]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>0</RW>
          <DataType>en</DataType>
          <Options>
          </Options>
        </Field>
        <Field>
          <StartBit>4</StartBit>
          <BitLength>5</BitLength>
          <ShortName><![CDATA[MEM_SEL]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>0</RW>
          <DataType>uns</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>110</Address>
      <ShortName><![CDATA[MEM_START_ADDR]]></ShortName>
      <Name><![CDATA[Memory Start Address]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[START_ADDR]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>0</RW>
          <DataType>uns</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>111</Address>
      <ShortName><![CDATA[MEM_R_W]]></ShortName>
      <Name><![CDATA[Memory Read/Write]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[MEM_R_W]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[]]></Description>
          <RW>0</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>112</Address>
      <ShortName><![CDATA[DMP_CFG_1]]></ShortName>
      <Name><![CDATA[DMP Configuration 1]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
      </Fields>
    </Register>
    <Register>
      <Address>113</Address>
      <ShortName><![CDATA[DMP_CFG_2]]></ShortName>
      <Name><![CDATA[DMP Configuration 2]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
      </Fields>
    </Register>
    <Register>
      <Address>114</Address>
      <ShortName><![CDATA[FIFO_COUNTH]]></ShortName>
      <Name><![CDATA[FIFO Count High Byte]]></Name>
      <Description><![CDATA[These registers keep track of the number of samples currently in the FIFO buffer. These registers shadow the FIFO Count value. Both registers are loaded with the current sample count when FIFO_COUNT_H (Register 72) is read.

Note: Reading only FIFO_COUNT_L will not update the registers to the current sample count. FIFO_COUNT_H must be accessed first to update the contents of both these registers.

FIFO_COUNT should always be read in high-low order in order to guarantee that the most current FIFO Count value is read.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>15</StartBit>
          <BitLength>16</BitLength>
          <ShortName><![CDATA[FIFO_COUNT]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[16-bit unsigned value. Indicates the number of bytes stored in the FIFO buffer. This number is in turn the number of bytes that can be read from the FIFO buffer and it is directly proportional to the number of samples available given the set of sensor data bound to be stored in the FIFO (register 35 and 36).]]></Description>
          <RW>0</RW>
          <DataType>uns</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>115</Address>
      <ShortName><![CDATA[FIFO_COUNTL]]></ShortName>
      <Name><![CDATA[FIFO Count Low Byte]]></Name>
      <Description><![CDATA[]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
      </Fields>
    </Register>
    <Register>
      <Address>116</Address>
      <ShortName><![CDATA[FIFO_R_W]]></ShortName>
      <Name><![CDATA[FIFO Read/Write]]></Name>
      <Description><![CDATA[This register is used to read and write data from the FIFO buffer. Data is written to the FIFO in order of register number (from lowest to highest). If all the FIFO enable flags (see below) are enabled and all External Sensor Data registers (Registers 73 to 96) are associated with a Slave device, the contents of registers 59 through 96 will be written in order at the Sample Rate.

The contents of the sensor data registers (Registers 59 to 96) are written into the FIFO buffer when their corresponding FIFO enable flags are set to 1 in FIFO_EN (Register 35). An additional flag for the sensor data registers associated with I2C Slave 3 can be found in I2C_MST_CTRL (Register 36).

If the FIFO buffer has overflowed, the status bit FIFO_OFLOW_INT is automatically set to 1. This bit is located in INT_STATUS (Register 58). When the FIFO buffer has overflowed, the oldest data will be lost and new data will be written to the FIFO.

If the FIFO buffer is empty, reading this register will return the last byte that was previously read from the FIFO until new data is available. The user should check FIFO_COUNT to ensure that the FIFO buffer is not read when empty.]]></Description>
      <Size>8</Size>
      <RW>0</RW>
      <Fields>
        <Field>
          <StartBit>7</StartBit>
          <BitLength>8</BitLength>
          <ShortName><![CDATA[FIFO_R_W]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[8-bit data transferred to and from the FIFO buffer.]]></Description>
          <RW>0</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
    <Register>
      <Address>117</Address>
      <ShortName><![CDATA[WHO_AM_I]]></ShortName>
      <Name><![CDATA[]]></Name>
      <Description><![CDATA[This register is used to verify the identity of the device. The contents of WHO_AM_I are the upper 6 bits of the MPU-60X0’s 7-bit I2C address. The least significant bit of the MPU-60X0’s I2C address is determined by the value of the AD0 pin. The value of the AD0 pin is not reflected in this register.

The default value of the register is 0x68.

Bits 0 and 7 are reserved. (Hard coded to 0)]]></Description>
      <Size>8</Size>
      <RW>1</RW>
      <Fields>
        <Field>
          <StartBit>6</StartBit>
          <BitLength>6</BitLength>
          <ShortName><![CDATA[WHO_AM_I]]></ShortName>
          <Name><![CDATA[]]></Name>
          <Description><![CDATA[Contains the 6-bit I2C address of the MPU-60X0. The Power-On-Reset value of Bit6:Bit1 is 110 100.]]></Description>
          <RW>1</RW>
          <DataType>any</DataType>
          <Options>
          </Options>
        </Field>
      </Fields>
    </Register>
  </Registers>
</Device>
